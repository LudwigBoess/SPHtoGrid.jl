var documenterSearchIndex = {"docs":
[{"location":"effects/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"You can find some examples here for common maps. These examples assume that you also have GadgetIO.jl, GadgetUnits.jl and SPHKernels.jl installed.","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"In all examples snap_base points to the snapshot you want to map and map_path points to the folder where you want to store the fits files.","category":"page"},{"location":"effects/#Read-data-and-convert-units","page":"Examples","title":"Read data and convert units","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"First we need to read the data and convert it to physical units (unless you want to bother with comoving coordinates and h0 in cosmological simulations).","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"Here halo_pos is the position of the halo you want to map and rvir is its virial radius.","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"# read the header\nh = read_header(snap_base)\n# define a unit conversion struct from `GadgetUnits.jl`\nGU = GadgetPhysical(h)\n\n# define the blocks you want to read\nblocks = [\"POS\", \"VEL\", \"HSML\", \"RHO\", \"U\", \"MASS\", \"BFLD\", \"MACH\"]\n\n# read all particles in a cubic volume around the halo\ndata = read_particles_in_volume(snap_base, blocks, halo_pos, rvir)\n\n# convert to physical code units for mapping\npos  = data[\"POS\"]  .* GU.x_physical\nhsml = data[\"HSML\"] .* GU.x_physical\nrho  = data[\"RHO\"]  .* GU.rho_physical\nmass = data[\"MASS\"] .* GU.m_physical\n\n# we want to map the entire cube we read\nxy_size = 2rvir\nz_size  = 2rvir\n\n# define mapping parameters and convert to physical units\npar = mappingParameters(center = halo_pos .* GU.x_physical,\n                        x_size = xy_size * GU.x_physical,\n                        y_size = xy_size * GU.x_physical,\n                        z_size = z_size * GU.x_physical,\n                        Npixels = 1024,\n                        boxsize=h.boxsize)\n\n# define the kernel you want to use for mapping\nk = WendlandC4(Float64, 2)","category":"page"},{"location":"effects/#D-surface-density","page":"Examples","title":"2D surface density","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"To get the projected 2D surface density from your data you can use","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"# you need to make a copy of the positions if you plan to re-use them\n# the mapping shifts them in place\npos_map = copy(pos)\n\n# convert density to physical cgs units\nrho_gcm3 = data[\"RHO\"] .* GU.rho_cgs\n\n# to get the integrated values along the LOS you need physical weights and not reduce the image\nweights = part_weight_physical(length(hsml), par, GU.x_cgs)\n\n# actual mapping\nmap = sphMapping(pos_map, hsml, mass, rho,\n                rho_gcm3, weights,\n                param = par, kernel = k,\n                reduce_image = false)\n\n# filename of the output image\nfo_image = map_path * \"rho.fits\"\n\n# store the fits image\nwrite_fits_image(fo_image, quantitiy_map, par, snap = snap, units = \"g/cm^2\")","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"The units in this case are of course gcm^2.","category":"page"},{"location":"effects/#Magnetic-Field","page":"Examples","title":"Magnetic Field","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"To map the mean magnetic field along the LOS you need to use the density as weight (this is the default behaviour, so you can leave the arguemnt empty) and set reduce_image=true","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"# you need to make a copy of the positions if you plan to re-use them\n# the mapping shifts them in place\npos_map = copy(pos)\n\n# compute absolute value of magnetic field in muG\nB = @. 1.e6 * √(data[\"BFLD\"][1, :]^2 + data[\"BFLD\"][2, :]^2 + data[\"BFLD\"][3, :]^2)\n\n\n# actual mapping\nmap = sphMapping(pos_map, hsml, mass, rho, B,\n                param = par, kernel = k,\n                reduce_image = true)\n\n# filename of the output image\nfo_image = map_path * \"B.fits\"\n\n# store the fits image\nwrite_fits_image(fo_image, quantitiy_map, par, snap = snap, units = \"muG\")","category":"page"},{"location":"effects/#X-Ray-emission","page":"Examples","title":"X-Ray emission","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"To map the Xray surface brightness please use","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"x_ray_emissivity","category":"page"},{"location":"effects/#SPHtoGrid.x_ray_emissivity","page":"Examples","title":"SPHtoGrid.x_ray_emissivity","text":"x_ray_emissivity(T_keV::Vector{<:Real}, \n                 rho_cgs::Vector{<:Real},\n                 metalicity::Union{Vector{Float64, Nothing}}=nothing; \n                 E0::Real=0.1, E1::Real=2.4, \n                 xH::Real=0.752,\n                 cooling_function::Bool=false,\n                 z::Real=0.0)\n\nX-Ray emissivity for particles with temperature T_keV in keV, and density rho_cgs in gcm^3. If available you can also add the metalicity in the gas. Emin and Emax give the minimum and maximum energy of the oberservation. xH gives the hydrogen fraction used in the simulation.\n\nReturns\n\nX-Ray emissivity in units of [erg/s/cm^3].\n\nArguments:\n\nT_keV: SPH particle temperature [keV]\nm_cgs: SPH particle mass in [g]\nrho_cgs: SPH particle density in [g/cm^3]\nE0: Minimum photon energy for Xray spectrum [keV]\nE1: Maximum photon energy for Xray spectrum [keV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/","page":"Examples","title":"Examples","text":"Here is an example code","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"# you need to make a copy of the positions if you plan to re-use them\n# the mapping shifts them in place\npos_map = copy(pos)\n\n# get temperature in keV\nT_keV = get_T_keV(data[\"U\"], data[\"MASS\"], GU.T_eV)\n\n# convert density to physical cgs units\nrho_gcm3 = data[\"RHO\"] .* GU.rho_cgs\n\n# calculate X-ray emission per particle in the energy band Emin = 0.1 keV, Emax = 2.4 keV\nXray = x_ray_emissivity(T_keV, rho_cgs,\n                        E0=0.1, E1=2.4)\n\n# to get the integrated values along the LOS you need physical weights and not reduce the image\nweights = part_weight_physical(length(hsml), par, GU.x_cgs)\n\n# actual mapping\nmap = sphMapping(pos_map, hsml, mass, rho, Xray, weights,\n                param = par, kernel = k,\n                reduce_image = true)\n\n# filename of the output image\nfo_image = map_path * \"Xray.fits\"\n\n# store the fits image\nwrite_fits_image(fo_image, quantitiy_map, par, snap = snap, units = \"erg/s/cm^2\")","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"This returns a map in the units ergscm^2.","category":"page"},{"location":"effects/#Sunyaev-Z'eldovich-Effect","page":"Examples","title":"Sunyaev-Z'eldovich Effect","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"You can compute compton-Y parameter, thermal and kinetic SZ effect with these functions:","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"comptonY\nthermal_SZ\nkinetic_SZ","category":"page"},{"location":"effects/#SPHtoGrid.comptonY","page":"Examples","title":"SPHtoGrid.comptonY","text":"comptonY(n_cm3::Real, T_K::Real, z::Real)\n\nComputes the Compton-Y parameter from electron density n_cm3 and temperature T in Kelvin at redshift z.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nT_K: SPH particle temperature [K]\nz: Redshift.\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\ncomptonY(n_cm3::Vector{<:Real}, T_K::Vector{<:Real}, z::Real)\n\nComputes the Compton-Y parameter from electron density n_cm3 and temperature T in Kelvin at redshift z.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nT_K: SPH particle temperature [K]\nz: Redshift\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.thermal_SZ","page":"Examples","title":"SPHtoGrid.thermal_SZ","text":"thermal_SZ( n_cm3::Vector{<:Real}, T_K::Vector{<:Real},\n            z::Real=0.0, ν::Real=1.44e9; \n            DI_over_I::Bool=false )\n\nComputes the thermal Sunyaev-Zel'dovich effect for electron density n_cm3 and temperature T_K in Kelvin at redshift z and observer frequency ν. DI_over_I outputs in units of dII if set to true and dT/T otherwise.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nT_K: SPH particle temperature [K]\nz: Redshift\nν: Observing frequency\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.kinetic_SZ","page":"Examples","title":"SPHtoGrid.kinetic_SZ","text":"kinetic_SZ(n_cm3::Real, vel_y_cgs::Real, \n           z::Real=0.0, ν::Real=1.e9;\n           DI_over_I::Bool=false)\n\nComputes the kinetic Sunyaev-Zel'dovich effect from electron density n_cm3 and velocity in y-direction to the projection plane in cgs units vel_y_cgs. If DI_over_I is set to true you also need to provide an observation frequency ν and redshift z.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nvel_y_cgs: SPH particle velocity in y-direction in [cm/s]\nz: Redshift\nν: Observing frequency\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/","page":"Examples","title":"Examples","text":"Example for the thermal SZ effect","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"# you need to make a copy of the positions if you plan to re-use them\n# the mapping shifts them in place\npos_map = copy(pos)\n\n# get temperature in K\nT_K = data[\"U\"] .* GU.T_K\n\n# convert code density to electron density\nn_cm3 = data[\"RHO\"] .* GU.rho_ncm3\n\n# calculate thermal SZ for redshift given in header\nth_SZ = thermal_SZ(n_cm3, T_K, h.z)\n\n# to get the integrated values along the LOS you need physical weights and not reduce the image\nweights = part_weight_physical(length(hsml), par, GU.x_cgs)\n\n# actual mapping\nmap = sphMapping(pos_map, hsml, mass, rho, th_SZ, weights,\n                param = par, kernel = k,\n                reduce_image = false)\n\n# filename of the output image\nfo_image = map_path * \"ThermalSZ.fits\"\n\n# store the fits image\nwrite_fits_image(fo_image, quantitiy_map, par, snap = snap, units = \"\")","category":"page"},{"location":"effects/#Gamma-Ray-emission","page":"Examples","title":"Gamma Ray emission","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"You can compute gamma-ray related maps as in Pfrommer & Enßlin (2004) with:","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"jγ_PE04\nλγ_PE04\ngamma_luminosity_pions_PE04\ngamma_flux_pions_PE04","category":"page"},{"location":"effects/#SPHtoGrid.jγ_PE04","page":"Examples","title":"SPHtoGrid.jγ_PE04","text":"jγ_PE04(rho_cgs::Real, T_K::Real, α_p::Real, Eγ::Real; \n        Xcr::Real=0.5, xH::Real=0.752)\n\nGamma-ray emissivity at photon energy Eγ [GeV] for thermal gas with properties rho_cgs [g/cm^3] and T_K [K]. Sets up a CR proton spectrum with energy slope α_p as a fraction Xcr of the thermal energy density. Returns emissivity in units [GeV cm^-3 s^-1 ]. See Pfrommer&Enßlin (2004), Eq. 19.\n\nFunction Arguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nEγ: Photon energy [GeV]\nXcr: CR proton to thermal pressure ratio.\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nFor mean value along line-of-sight:\n\nweights: rho (weight with density)\nreduce_image: true\n\nFor integral along line-of-sight, aka surface brightness:\n\nweights: part_weight_physical\nreduce_image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.λγ_PE04","page":"Examples","title":"SPHtoGrid.λγ_PE04","text":"λγ_PE04(rho_cgs::Real, T_K::Real, α_p::Real; \n        Xcr::Real=0.5,\n        Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,\n        xH::Real=0.752)\n\nNumber of γ-ray photons produced per time and volume from a proton spectrum given as a fraction Xcr of the energy density defined by rho_cgs [g/cm^3] and T_K [K], with a powerlaw slope in energy α_p. Integrated between photon energies Eγ_π0_min and Eγ_π0_max [GeV]. Returns number of photons in energy band in units of [γ cm^-3 s^-1]. See Pfrommer&Enßlin (2004), Eq. 25.\n\nFunction Arguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nXcr: CR proton to thermal pressure ratio.\nEγ_π0_min: Minimum photon energy for γ-ray spectrum [GeV]\nEγ_π0_max: Maximum photon energy for γ-ray spectrum [GeV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nFor mean value along line-of-sight:\n\nweights: rho (weight with density)\nreduce_image: true\n\nFor integral along line-of-sight, aka surface brightness:\n\nweights: part_weight_physical\nreduce_image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.gamma_luminosity_pions_PE04","page":"Examples","title":"SPHtoGrid.gamma_luminosity_pions_PE04","text":"gamma_luminosity_pions_PE04(rho_cgs::Real, m_cgs::Real, T_K::Real, α_p::Real;\n                            Xcr::Real=0.5,\n                            Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,\n                            xH::Real=0.752)\n\nγ-ray luminosity produced from a proton spectrum given as a fraction Xcr of the energy density defined by rho_cgs [g/cm^3] and T_K [K],  with a powerlaw slope in energy α_p. Integrated over SPH particle volume for particle of mass m_cgs [g]. Integrated between photon energies Eγ_π0_min and Eγ_π0_max [GeV]. Returns total luminosity integrated over energy band in units of [GeV s^-1]. See Pfrommer&Enßlin (2004), Eq. 25.\n\nArguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nm_cgs: SPH particle mass in [g]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nXcr: CR proton to thermal pressure ratio.\nEγ_π0_min: Minimum photon energy for γ-ray spectrum [GeV]\nEγ_π0_max: Maximum photon energy for γ-ray spectrum [GeV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nweight function: part_weight_one\nreduce image: true\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.gamma_flux_pions_PE04","page":"Examples","title":"SPHtoGrid.gamma_flux_pions_PE04","text":"gamma_flux_pions_PE04(rho_cgs::Real, m_cgs::Real, T_K::Real, α_p::Real, d::Real;\n                      Xcr::Real=0.5,\n                      Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,\n                      xH::Real=0.752)\n\nFlux of γ-ray photons produced from a proton spectrum given as a fraction Xcr of the energy density defined by rho_cgs [g/cm^3] and T_K [K],  with a powerlaw slope in energy α_p.  Integrated over SPH particle volume for particle of mass m_cgs [g]. Flux from a distance d [cm]. Integrated between photon energies Eγ_π0_min and Eγ_π0_max [GeV]. Returns total number of photons in energy band in untis of [γ cm^-2 s^-1]. See Pfrommer&Enßlin (2004), Eq. 25.\n\nArguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nm_cgs: SPH particle mass in [g]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nd: Distance to SPH particle or halo [cm].\nXcr: CR proton to thermal pressure ratio.\nEγ_π0_min: Minimum photon energy for γ-ray spectrum [GeV]\nEγ_π0_max: Maximum photon energy for γ-ray spectrum [GeV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nweight function: part_weight_one\nreduce image: true\n\n\n\n\n\n","category":"function"},{"location":"effects/","page":"Examples","title":"Examples","text":"Example for gamma-ray luminosity","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"# you need to make a copy of the positions if you plan to re-use them\n# the mapping shifts them in place\npos_map = copy(pos)\n\n# convert density to physical cgs units\nrho_gcm3 = data[\"RHO\"] .* GU.rho_cgs\n\n# convert mass to physical cgs units\nm_cgs = data[\"MASS\"] .* GU.m_cgs\n\n# get temperature in keV\nT_keV = data[\"U\"] .* GU.T_K\n\n# calculate Iγ-ray luminosity per particle in the energy band Emin = 0.1 GeV, Emax = 200 GeV\n# for proton spectra with slope 2.235\nLγ = gamma_luminosity_pions_PE04.(T_keV, m_cgs, rho_cgs, 2.235)\n\n# weights ones means you sum up the values along the LOS\nweights = ones(length(Lγ))\n\n# actual mapping\nmap = sphMapping(pos_map, hsml, mass, rho, Lγ, weights,\n                param = par, kernel = k,\n                reduce_image = true)\n\n# filename of the output image\nfo_image = map_path * \"L_gamma.fits\"\n\n# store the fits image\nwrite_fits_image(fo_image, quantitiy_map, par, snap = snap, units = \"GeV/s\")","category":"page"},{"location":"effects/#Synchrotron-Emission","page":"Examples","title":"Synchrotron Emission","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"I implemented a number of different functions to compute synchrotron emissivity by shock accelerated electrons. Please use with caution as there are still some errors to be fixed!","category":"page"},{"location":"effects/","page":"Examples","title":"Examples","text":"analytic_synchrotron\nanalytic_synchrotron_GS\nanalytic_synchrotron_Longair\nanalytic_synchrotron_HB07","category":"page"},{"location":"effects/#SPHtoGrid.analytic_synchrotron","page":"Examples","title":"SPHtoGrid.analytic_synchrotron","text":"analytic_synchrotron(P_cgs::Array{<:Real}, B_cgs::Array{<:Real}, \n                     Mach::Array{<:Real}, θ_B::Union{Nothing,Array{<:Real}}=nothing;\n                     dsa_model::Union{Integer,AbstractShockAccelerationEfficiency}=1, \n                     ν0::Real=1.4e9,\n                     K_ep::Real=0.01, CR_Emin::Real=1.0,\n                     spectrum::Union{Nothing,Function}=nothing,\n                     integrate_pitch_angle::Bool=true,\n                     polarisation::Bool=false,\n                     show_progress::Bool=false)\n\nComputes the analytic synchrotron emission from a spectrum of electrons by explicitly integrating over the distribution function. The integral over the spectrum must be normalized to 1. The total energy density of the relativistic electrons is given by the CR to thermal pressure ratio obtained by employing a DSA model and computing Xcr as in Pfrommer et. al. (2017).\n\nReturns synchrotron emissivity j_nu in units [erg/s/Hz/cm^3].\n\nArguments\n\nP_cgs::Array{<:Real}:   Thermal energy density in erg/cm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nMach::Array{<:Real}:    Mach number.\nθ_B::Union{Nothing,Array{<:Real}}=nothing: Shock obliquity (optional).\n\nKeyword Arguments\n\nν0::Real=1.4e9:           Observation frequency in Hz.\ndsa_model:      Diffusive Shock Acceleration model. Takes values 0...4, or custom model. See next section.\nK_ep::Real=0.01:           Ratio of CR proton to electron energy acceleration.\nCR_Emin::Real=1:           Injection energy of CR electron population in GeV.\nspectrum::Union{Nothing,Function}=nothing: Spectrum function. Must be normalized so that the integral over it is 1.\nintegrate_pitch_angle::Bool=true: Optional avoid pitch angle integration to reduce computational cost.\npolarisation::Bool=false: Set to true if you want to compute the polarized emission instead of the total intensity.\nshow_progress::Bool=false: Enables a progress bar if set to true.\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.analytic_synchrotron_GS","page":"Examples","title":"SPHtoGrid.analytic_synchrotron_GS","text":"analytic_synchrotron_GS( rho_cgs::Array{<:Real}, B_cgs::Array{<:Real},\n                         T_K::Array{<:Real}, Mach::Array{<:Real};\n                         xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.44e9,\n                         integrate_pitch_angle::Bool=true )\n\nComputes the analytic synchrotron emission with the simplified approach described in Ginzburg & Syrovatskii 1965, \"Cosmic Magnetobremsstrahlung\". Uses the implementaion from Donnert et. al. (2016).\n\nReturns synchrotron emissivity j_nu in units [erg/s/Hzcm^3].\n\nArguments\n\nrho_cgs::Array{<:Real}: Density in gcm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nT_K::Array{<:Real}:     Temperature in Kelvin.\nMach::Array{<:Real}:    Mach number.\nθ_B::Union{Nothing,Array{<:Real}}=nothing: Shock obliquity (optional).\n\nKeyword Arguments\n\nxH::Float64 = 0.76:        Hydrogen fraction of the simulation, if run without chemical model.\nν0::Real=1.44e9:           Observation frequency in Hz.\ndsa_model::Integer=1:      Diffusive Shock Acceleration model. Takes values 0...4, see next section.\nK_ep::Real=0.01:           Ratio of CR proton to electron energy acceleration.\nshow_progress::Bool=false: Enables a progress bar if set to true\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.analytic_synchrotron_Longair","page":"Examples","title":"SPHtoGrid.analytic_synchrotron_Longair","text":"analytic_synchrotron_emission( rho_cgs::Array{<:Real}, B_cgs::Array{<:Real},\n                               T_K::Array{<:Real}, Mach::Array{<:Real};\n                               xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.44e9,\n                               integrate_pitch_angle::Bool=true )\n\nComputes the analytic synchrotron emission with the simplified approach described in Longair Eq. 8.128. Returns J_ν in units [erg/cm^3/Hz/s].\n\nArguments\n\nrho_cgs::Array{<:Real}: Density in gcm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nT_K::Array{<:Real}:     Temperature in Kelvin.\nMach::Array{<:Real}:    Mach number.\n\nKeyword Arguments\n\nxH::Float64 = 0.76:               Hydrogen fraction of the simulation, if run without chemical model.\ndsa_model::Integer=1:             Diffuse-Shock-Acceleration model. Takes values 0...4, see next section.\nν0::Real=1.44e9:                  Observation frequency in Hz.\nK_ep::Real=0.01:                  Ratio of CR proton to electron energy density.\nintegrate_pitch_angle::Bool=true: Integrates over the pitch angle as in Longair Eq. 8.87.\nconvert_to_mJy::Bool=false:       Convert the result from ergcm^3Hzs to mJycm.\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.analytic_synchrotron_HB07","page":"Examples","title":"SPHtoGrid.analytic_synchrotron_HB07","text":"analytic_synchrotron_HB07( rho_cgs::Array{<:Real}, m_cgs::Array{<:Real}, hsml_cgs::Array{<:Real},\n                           B_cgs::Array{<:Real}, T_keV::Array{<:Real}, Mach::Array{<:Real},\n                           θ_B::Union{Nothing, Array{<:Real}}=nothing;\n                           xH::Real=0.752, ν0::Real=1.4e9, z::Real=0.0,\n                           dsa_model::Union{Nothing,Integer,AbstractShockAccelerationEfficiency}=nothing,\n                           ξe::Real=1.e-5,\n                           show_progress::Bool=false )\n\nComputes the analytic synchrotron emission with the simplified approach described in Hoeft&Brüggen (2007), following approach by Wittor et. al. (2017).\n\nReturns synchrotron emissivity j_nu in units [erg/s/Hz/cm^3].\n\nArguments\n\nrho_cgs::Array{<:Real}:  Density in gcm^3.\nm_cgs::Array{<:Real}:    Particle mass in g.\nhsml_cgs::Array{<:Real}: HSML block in cm.\nB_cgs::Array{<:Real}:    Magnetic field in G.\nT_keV::Array{<:Real}:    Temperature in keV.\nMach::Array{<:Real}:     Sonic Mach number.\nθ_B::Union{Nothing,Array{<:Real}}=nothing: Shock obliquity (optional).\n\nKeyword Arguments\n\nxH::Float64 = 0.76:        Hydrogen fraction of the simulation, if run without chemical model.\nν0::Real=1.44e9:           Observation frequency in Hz.\nz::Real=0.0:               Redshift of the simulation.\ndsa_model=nothing:         Diffusive Shock Acceleration model. If set to a value overwrites the default Hoeft&Brüggen acceleration model. See next section.\nξe::Real=1.e-5:            Ratio of CR proton to electron energy acceleration. Given as a fraction of thermal gas, essenitally Xcr * Kep.                               Default value from Nuza+2017. For dsa_model != nothing use something like ξe = 1.e-4.\nshow_progress::Bool=false: Enables a progress bar if set to true.\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"effects/#Image-Functions","page":"Examples","title":"Image Functions","text":"","category":"section"},{"location":"effects/#General","page":"Examples","title":"General","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"surface_brightness_to_luminosity","category":"page"},{"location":"effects/#SPHtoGrid.surface_brightness_to_luminosity","page":"Examples","title":"SPHtoGrid.surface_brightness_to_luminosity","text":"surface_brightness_to_luminosity(map::Matrix{<:Real}, pixelSideLength::Real; unit_factor::Real=1.0)\n\nConverts a map of surface brightness to luminosity per pixel. Uses pixelSideLength as the diameter of a pixel in [kpc]. If unit_factor is provided it is multiplied to every pixel to perform unit conversion.\n\n\n\n\n\nsurface_brightness_to_luminosity(map::Matrix{<:Real}, par::mappingParameters; unit_factor::Real=1.0)\n\nConverts a map of surface brightness to luminosity per pixel. If unit_factor is provided it is multiplied to every pixel to perform unit conversion.\n\n\n\n\n\n","category":"function"},{"location":"effects/#Synchrotron-Specific","page":"Examples","title":"Synchrotron Specific","text":"","category":"section"},{"location":"effects/","page":"Examples","title":"Examples","text":"synchrotron_SB_to_luminosity\ntotal_synch_luminosity_from_SB\nbeam_in_kpc\nconvert_Pnu_map_to_mJy_beam\npolarisation_fraction\npolarisation_angle","category":"page"},{"location":"effects/#SPHtoGrid.synchrotron_SB_to_luminosity","page":"Examples","title":"SPHtoGrid.synchrotron_SB_to_luminosity","text":"synchrotron_SB_to_luminosity(map, pixelSideLength::Real)\n\nConverts a map of synchrotron surface brightness [erg/s/Hz/cm^2] to synchrotron luminosity [W/Hz]. Uses pixelSideLength as the diameter of a pixel in [kpc].\n\n\n\n\n\nsynchrotron_SB_to_luminosity(map, par::mappingParameters)\n\nConverts a map of synchrotron surface brightness [erg/s/Hz/cm^2] to synchrotron luminosity [W/Hz]. Uses par as the mappingParameters of the original map.\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.total_synch_luminosity_from_SB","page":"Examples","title":"SPHtoGrid.total_synch_luminosity_from_SB","text":"total_synch_luminosity_from_SB(map::Matrix{<:Real}, pixelSideLength::Real)\n\nComputes the total synchrotron luminosity in [W/Hz] from a map of synchrotron surface brightness in [erg/s/Hz/cm^2].\n\n\n\n\n\ntotal_synch_luminosity_from_SB(map::Matrix{<:Real}, par::mappingParameters)\n\nComputes the total synchrotron luminosity in [W/Hz] from a map of synchrotron surface brightness in [erg/s/Hz/cm^2].\n\n\n\n\n\ntotal_synch_luminosity_from_SB(filename::String)\n\nComputes the total synchrotron luminosity in [W/Hz] from a map of synchrotron surface brightness in [erg/s/Hz/cm^2].\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.beam_in_kpc","page":"Examples","title":"SPHtoGrid.beam_in_kpc","text":"beam_in_kpc(θ_beam::Vector{Union{Real, Unitful.AbstractQuantity}}, \n            c::Cosmology.AbstractCosmology, z::Real)\n\nConverts the beam from arcmin to kpc.\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.convert_Pnu_map_to_mJy_beam","page":"Examples","title":"SPHtoGrid.convert_Pnu_map_to_mJy_beam","text":"convert_Pnu_map_to_mJy_beam(map::Matrix{<:Real}, \n                            d_pixel::Real,\n                            beam::Vector{Union{Real, Unitful.AbstractQuantity}}, \n                            c::Cosmology.AbstractCosmology, \n                            z::Real)\n\nConverts a map from units [W / Hz] to [mJy / beam].\n\nParameters:\n\nmap: original map in [W / Hz].\nd_pixel: size of a pixel in kpc.\nbeam: dimensions of the beam in arcmin.\nc: Cosmology used for conversion.\nz: Redshift of the image.\n\n\n\n\n\nconvert_Pnu_map_to_mJy_beam(map::Matrix{<:Real}, \n                            d_pixel::Real,\n                            beam::Union{Real, Unitful.AbstractQuantity}, \n                            c::Cosmology.AbstractCosmology, \n                            z::Real)\n\nConverts a map from units [W / Hz] to [mJy / beam] for a circular beam.\n\nParameters:\n\nmap: original map in [W / Hz].\nd_pixel: size of a pixel in kpc.\nbeam: radius of the beam in arcmin.\nc: Cosmology used for conversion.\nz: Redshift of the image.\n\n\n\n\n\nconvert_Pnu_map_to_mJy_beam(map::Matrix{<:Real}, \n                            d_pixel::Real,\n                            beam::Union{T, Vector{T}}, \n                            h::AbstractGadgetHeader) where T::Union{Real, Unitful.AbstractQuantity}\n\nConverts a map from units [W / Hz] to [mJy / beam] by using a Gadget header.\n\nParameters:\n\nmap: original map in [W / Hz].\nd_pixel: size of a pixel in kpc.\nbeam: radius/dimensions of the beam in arcmin.\nh: Gadget header of simulation\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.polarisation_fraction","page":"Examples","title":"SPHtoGrid.polarisation_fraction","text":"polarisation_fraction(Q_image, U_image, Iν_image, Iν_cutoff= 0.0)\n\nCompute the polarisation fraction image from Stokes Q and U images.\n\n\n\n\n\n","category":"function"},{"location":"effects/#SPHtoGrid.polarisation_angle","page":"Examples","title":"SPHtoGrid.polarisation_angle","text":"polarisation_angle(Q_image, U_image, Iν_image=nothing, Iν_cutoff= 0.0)\n\nCompute the polarisation fraction image from Stokes Q and U images.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = SPHtoGrid\nDocTestSetup = quote\n    using SPHtoGrid\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHtoGrid.analytic_synchrotron","page":"API reference","title":"SPHtoGrid.analytic_synchrotron","text":"analytic_synchrotron(P_cgs::Array{<:Real}, B_cgs::Array{<:Real}, \n                     Mach::Array{<:Real}, θ_B::Union{Nothing,Array{<:Real}}=nothing;\n                     dsa_model::Union{Integer,AbstractShockAccelerationEfficiency}=1, \n                     ν0::Real=1.4e9,\n                     K_ep::Real=0.01, CR_Emin::Real=1.0,\n                     spectrum::Union{Nothing,Function}=nothing,\n                     integrate_pitch_angle::Bool=true,\n                     polarisation::Bool=false,\n                     show_progress::Bool=false)\n\nComputes the analytic synchrotron emission from a spectrum of electrons by explicitly integrating over the distribution function. The integral over the spectrum must be normalized to 1. The total energy density of the relativistic electrons is given by the CR to thermal pressure ratio obtained by employing a DSA model and computing Xcr as in Pfrommer et. al. (2017).\n\nReturns synchrotron emissivity j_nu in units [erg/s/Hz/cm^3].\n\nArguments\n\nP_cgs::Array{<:Real}:   Thermal energy density in erg/cm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nMach::Array{<:Real}:    Mach number.\nθ_B::Union{Nothing,Array{<:Real}}=nothing: Shock obliquity (optional).\n\nKeyword Arguments\n\nν0::Real=1.4e9:           Observation frequency in Hz.\ndsa_model:      Diffusive Shock Acceleration model. Takes values 0...4, or custom model. See next section.\nK_ep::Real=0.01:           Ratio of CR proton to electron energy acceleration.\nCR_Emin::Real=1:           Injection energy of CR electron population in GeV.\nspectrum::Union{Nothing,Function}=nothing: Spectrum function. Must be normalized so that the integral over it is 1.\nintegrate_pitch_angle::Bool=true: Optional avoid pitch angle integration to reduce computational cost.\npolarisation::Bool=false: Set to true if you want to compute the polarized emission instead of the total intensity.\nshow_progress::Bool=false: Enables a progress bar if set to true.\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.analytic_synchrotron_GS","page":"API reference","title":"SPHtoGrid.analytic_synchrotron_GS","text":"analytic_synchrotron_GS( rho_cgs::Array{<:Real}, B_cgs::Array{<:Real},\n                         T_K::Array{<:Real}, Mach::Array{<:Real};\n                         xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.44e9,\n                         integrate_pitch_angle::Bool=true )\n\nComputes the analytic synchrotron emission with the simplified approach described in Ginzburg & Syrovatskii 1965, \"Cosmic Magnetobremsstrahlung\". Uses the implementaion from Donnert et. al. (2016).\n\nReturns synchrotron emissivity j_nu in units [erg/s/Hzcm^3].\n\nArguments\n\nrho_cgs::Array{<:Real}: Density in gcm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nT_K::Array{<:Real}:     Temperature in Kelvin.\nMach::Array{<:Real}:    Mach number.\nθ_B::Union{Nothing,Array{<:Real}}=nothing: Shock obliquity (optional).\n\nKeyword Arguments\n\nxH::Float64 = 0.76:        Hydrogen fraction of the simulation, if run without chemical model.\nν0::Real=1.44e9:           Observation frequency in Hz.\ndsa_model::Integer=1:      Diffusive Shock Acceleration model. Takes values 0...4, see next section.\nK_ep::Real=0.01:           Ratio of CR proton to electron energy acceleration.\nshow_progress::Bool=false: Enables a progress bar if set to true\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.analytic_synchrotron_HB07","page":"API reference","title":"SPHtoGrid.analytic_synchrotron_HB07","text":"analytic_synchrotron_HB07( rho_cgs::Array{<:Real}, m_cgs::Array{<:Real}, hsml_cgs::Array{<:Real},\n                           B_cgs::Array{<:Real}, T_keV::Array{<:Real}, Mach::Array{<:Real},\n                           θ_B::Union{Nothing, Array{<:Real}}=nothing;\n                           xH::Real=0.752, ν0::Real=1.4e9, z::Real=0.0,\n                           dsa_model::Union{Nothing,Integer,AbstractShockAccelerationEfficiency}=nothing,\n                           ξe::Real=1.e-5,\n                           show_progress::Bool=false )\n\nComputes the analytic synchrotron emission with the simplified approach described in Hoeft&Brüggen (2007), following approach by Wittor et. al. (2017).\n\nReturns synchrotron emissivity j_nu in units [erg/s/Hz/cm^3].\n\nArguments\n\nrho_cgs::Array{<:Real}:  Density in gcm^3.\nm_cgs::Array{<:Real}:    Particle mass in g.\nhsml_cgs::Array{<:Real}: HSML block in cm.\nB_cgs::Array{<:Real}:    Magnetic field in G.\nT_keV::Array{<:Real}:    Temperature in keV.\nMach::Array{<:Real}:     Sonic Mach number.\nθ_B::Union{Nothing,Array{<:Real}}=nothing: Shock obliquity (optional).\n\nKeyword Arguments\n\nxH::Float64 = 0.76:        Hydrogen fraction of the simulation, if run without chemical model.\nν0::Real=1.44e9:           Observation frequency in Hz.\nz::Real=0.0:               Redshift of the simulation.\ndsa_model=nothing:         Diffusive Shock Acceleration model. If set to a value overwrites the default Hoeft&Brüggen acceleration model. See next section.\nξe::Real=1.e-5:            Ratio of CR proton to electron energy acceleration. Given as a fraction of thermal gas, essenitally Xcr * Kep.                               Default value from Nuza+2017. For dsa_model != nothing use something like ξe = 1.e-4.\nshow_progress::Bool=false: Enables a progress bar if set to true.\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.analytic_synchrotron_Longair","page":"API reference","title":"SPHtoGrid.analytic_synchrotron_Longair","text":"analytic_synchrotron_emission( rho_cgs::Array{<:Real}, B_cgs::Array{<:Real},\n                               T_K::Array{<:Real}, Mach::Array{<:Real};\n                               xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.44e9,\n                               integrate_pitch_angle::Bool=true )\n\nComputes the analytic synchrotron emission with the simplified approach described in Longair Eq. 8.128. Returns J_ν in units [erg/cm^3/Hz/s].\n\nArguments\n\nrho_cgs::Array{<:Real}: Density in gcm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nT_K::Array{<:Real}:     Temperature in Kelvin.\nMach::Array{<:Real}:    Mach number.\n\nKeyword Arguments\n\nxH::Float64 = 0.76:               Hydrogen fraction of the simulation, if run without chemical model.\ndsa_model::Integer=1:             Diffuse-Shock-Acceleration model. Takes values 0...4, see next section.\nν0::Real=1.44e9:                  Observation frequency in Hz.\nK_ep::Real=0.01:                  Ratio of CR proton to electron energy density.\nintegrate_pitch_angle::Bool=true: Integrates over the pitch angle as in Longair Eq. 8.87.\nconvert_to_mJy::Bool=false:       Convert the result from ergcm^3Hzs to mJycm.\n\nDSA Models\n\nTakes either your self-defined AbstractShockAccelerationEfficiency (see DiffusiveShockAccelerationModels.jl for details!) or a numerical value as input. Numerical values correspond to:\n\n0: Kang et. al. (2007)\n1: Kang & Ryu (2013)\n2: Ryu et. al. (2019)\n3: Caprioli & Spitkovsky (2014)\n4: Pfrommer et. al. (2006)\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.beam_in_kpc-Tuple{Vector{<:Union{var\"#s381\", var\"#s380\"} where {var\"#s381\"<:Real, var\"#s380\"<:Unitful.AbstractQuantity}}, Cosmology.AbstractCosmology, Real}","page":"API reference","title":"SPHtoGrid.beam_in_kpc","text":"beam_in_kpc(θ_beam::Vector{Union{Real, Unitful.AbstractQuantity}}, \n            c::Cosmology.AbstractCosmology, z::Real)\n\nConverts the beam from arcmin to kpc.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.comptonY-Tuple{Real, Real, Real}","page":"API reference","title":"SPHtoGrid.comptonY","text":"comptonY(n_cm3::Real, T_K::Real, z::Real)\n\nComputes the Compton-Y parameter from electron density n_cm3 and temperature T in Kelvin at redshift z.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nT_K: SPH particle temperature [K]\nz: Redshift.\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.comptonY-Tuple{Vector{<:Real}, Vector{<:Real}, Real}","page":"API reference","title":"SPHtoGrid.comptonY","text":"comptonY(n_cm3::Vector{<:Real}, T_K::Vector{<:Real}, z::Real)\n\nComputes the Compton-Y parameter from electron density n_cm3 and temperature T in Kelvin at redshift z.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nT_K: SPH particle temperature [K]\nz: Redshift\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.convert_Pnu_map_to_mJy_beam-Tuple{Matrix{<:Real}, Real, Union{Real, Unitful.AbstractQuantity}, Cosmology.AbstractCosmology, Real}","page":"API reference","title":"SPHtoGrid.convert_Pnu_map_to_mJy_beam","text":"convert_Pnu_map_to_mJy_beam(map::Matrix{<:Real}, \n                            d_pixel::Real,\n                            beam::Union{Real, Unitful.AbstractQuantity}, \n                            c::Cosmology.AbstractCosmology, \n                            z::Real)\n\nConverts a map from units [W / Hz] to [mJy / beam] for a circular beam.\n\nParameters:\n\nmap: original map in [W / Hz].\nd_pixel: size of a pixel in kpc.\nbeam: radius of the beam in arcmin.\nc: Cosmology used for conversion.\nz: Redshift of the image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.convert_Pnu_map_to_mJy_beam-Tuple{Matrix{<:Real}, Real, Vector{<:Union{var\"#s380\", var\"#s379\"} where {var\"#s380\"<:Real, var\"#s379\"<:Unitful.AbstractQuantity}}, Cosmology.AbstractCosmology, Real}","page":"API reference","title":"SPHtoGrid.convert_Pnu_map_to_mJy_beam","text":"convert_Pnu_map_to_mJy_beam(map::Matrix{<:Real}, \n                            d_pixel::Real,\n                            beam::Vector{Union{Real, Unitful.AbstractQuantity}}, \n                            c::Cosmology.AbstractCosmology, \n                            z::Real)\n\nConverts a map from units [W / Hz] to [mJy / beam].\n\nParameters:\n\nmap: original map in [W / Hz].\nd_pixel: size of a pixel in kpc.\nbeam: dimensions of the beam in arcmin.\nc: Cosmology used for conversion.\nz: Redshift of the image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.convert_Pnu_map_to_mJy_beam-Union{Tuple{T}, Tuple{Matrix{<:Real}, Real, Union{Vector{T}, T}, GadgetIO.AbstractGadgetHeader}} where T<:(Union{var\"#s383\", var\"#s382\"} where {var\"#s383\"<:Real, var\"#s382\"<:Unitful.AbstractQuantity})","page":"API reference","title":"SPHtoGrid.convert_Pnu_map_to_mJy_beam","text":"convert_Pnu_map_to_mJy_beam(map::Matrix{<:Real}, \n                            d_pixel::Real,\n                            beam::Union{T, Vector{T}}, \n                            h::AbstractGadgetHeader) where T::Union{Real, Unitful.AbstractQuantity}\n\nConverts a map from units [W / Hz] to [mJy / beam] by using a Gadget header.\n\nParameters:\n\nmap: original map in [W / Hz].\nd_pixel: size of a pixel in kpc.\nbeam: radius/dimensions of the beam in arcmin.\nh: Gadget header of simulation\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.density_2D","page":"API reference","title":"SPHtoGrid.density_2D","text":"density_2D( rho::Real, pixelSideLength::Real, \n            Mass::Real=1.989e43, Length::Real=3.085678e21)\n\nComputes the density in units of [g/cm^2].\n\nArguments:\n\nrho: SPH particle density in physical code units.\npixelSideLength: length of pixel in physical units.\nMass: Mass unit in [g].\nLength: Length unit in [cm]\n\nMapping settings\n\nweight function: part_weight_one\nreduce image: true\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.distributed_allsky_map-Tuple{String, Integer, Integer, Function}","page":"API reference","title":"SPHtoGrid.distributed_allsky_map","text":"distributed_allsky_map( allsky_filename::String, \n                        Nside::Integer, Nsubfiles::Integer, \n                        mapping_function::Function;\n                        reduce_image::Bool=true)\n\nDynamically dispatches workers to compute one allsky map per subfile, sum up the results and save to a fits file.\n\nArguments\n\nallsky_filename::String: Name of the file under which the image should be saved\nNside::Integer: Nside for healpix map, must be a power of 2! Nside = 2^N.\nNsubfiles::Integer: Number of subfiles the snapshot is distributed over.\nmapping_function::Function: The function to be executed per subfile. Must have a call to allsky_map as return value.\nreduce_image: If the final image should be divided by the weight image set to true\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.filter_particles_in_image-Union{Tuple{T}, Tuple{Array{T}, mappingParameters}, Tuple{Array{T}, mappingParameters, Bool}} where T","page":"API reference","title":"SPHtoGrid.filter_particles_in_image","text":"filter_particles_in_image(x, hsml, param::mappingParameters)\n\nChecks if a particle is contained in the image and returns an array of Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.gamma_flux_pions_PE04-NTuple{5, Real}","page":"API reference","title":"SPHtoGrid.gamma_flux_pions_PE04","text":"gamma_flux_pions_PE04(rho_cgs::Real, m_cgs::Real, T_K::Real, α_p::Real, d::Real;\n                      Xcr::Real=0.5,\n                      Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,\n                      xH::Real=0.752)\n\nFlux of γ-ray photons produced from a proton spectrum given as a fraction Xcr of the energy density defined by rho_cgs [g/cm^3] and T_K [K],  with a powerlaw slope in energy α_p.  Integrated over SPH particle volume for particle of mass m_cgs [g]. Flux from a distance d [cm]. Integrated between photon energies Eγ_π0_min and Eγ_π0_max [GeV]. Returns total number of photons in energy band in untis of [γ cm^-2 s^-1]. See Pfrommer&Enßlin (2004), Eq. 25.\n\nArguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nm_cgs: SPH particle mass in [g]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nd: Distance to SPH particle or halo [cm].\nXcr: CR proton to thermal pressure ratio.\nEγ_π0_min: Minimum photon energy for γ-ray spectrum [GeV]\nEγ_π0_max: Maximum photon energy for γ-ray spectrum [GeV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nweight function: part_weight_one\nreduce image: true\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.gamma_luminosity_pions_PE04-NTuple{4, Real}","page":"API reference","title":"SPHtoGrid.gamma_luminosity_pions_PE04","text":"gamma_luminosity_pions_PE04(rho_cgs::Real, m_cgs::Real, T_K::Real, α_p::Real;\n                            Xcr::Real=0.5,\n                            Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,\n                            xH::Real=0.752)\n\nγ-ray luminosity produced from a proton spectrum given as a fraction Xcr of the energy density defined by rho_cgs [g/cm^3] and T_K [K],  with a powerlaw slope in energy α_p. Integrated over SPH particle volume for particle of mass m_cgs [g]. Integrated between photon energies Eγ_π0_min and Eγ_π0_max [GeV]. Returns total luminosity integrated over energy band in units of [GeV s^-1]. See Pfrommer&Enßlin (2004), Eq. 25.\n\nArguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nm_cgs: SPH particle mass in [g]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nXcr: CR proton to thermal pressure ratio.\nEγ_π0_min: Minimum photon energy for γ-ray spectrum [GeV]\nEγ_π0_max: Maximum photon energy for γ-ray spectrum [GeV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nweight function: part_weight_one\nreduce image: true\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_map_grid_2D-Tuple{mappingParameters}","page":"API reference","title":"SPHtoGrid.get_map_grid_2D","text":"get_map_grid_2D(par::mappingParameters)\n\nReconstruct the 2D grid used for mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_map_grid_3D-Tuple{mappingParameters}","page":"API reference","title":"SPHtoGrid.get_map_grid_3D","text":"get_map_grid_3D(par::mappingParameters)\n\nReconstruct the 3D grid used for mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.healpix_map-NTuple{6, Any}","page":"API reference","title":"SPHtoGrid.healpix_map","text":"healpix_map(Pos, Hsml, M, Rho, Bin_q, Weights;\n            center::Vector{<:Real}=[0.0, 0.0, 0.0],\n            radius_limits::Vector{<:Real}=[0.0, Inf],\n            Nside::Integer=1024,\n            kernel::AbstractSPHKernel,\n            calc_mean::Bool=true\n            show_progress::Bool=true,\n            output_from_all_workers::Bool=false)\n\nCalculate an allsky map from SPH particles. Returns two HealpixMaps: (image, weight_image). To reduce the image afterwards divide image by weight_image. \n\nArguments:\n\nPos: Positions of particles in physical code units\nHSML: hsml of particles in physical code units \nM: Mass of particles in physical code units \nBin_Q: Quantitiy for binning in arb. units\nWeights: Weights for map\ncenter: Position from which projection is looking outwards in physical code units \nradius_limits: Inner and outer radius of the shell that should be mapped\nNside: Nside for healpix map, has to be a power of 2\ncalc_mean: Calculate the mean along the line of sight. If set to false only particles with Bin_Q > 0 contribute to the map.\nshow_progress: Print a progress bar \noutput_from_all_workers: Allow output from multiple workers. If set to false only the main process prints a progress bar.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.jγ_PE04-NTuple{4, Real}","page":"API reference","title":"SPHtoGrid.jγ_PE04","text":"jγ_PE04(rho_cgs::Real, T_K::Real, α_p::Real, Eγ::Real; \n        Xcr::Real=0.5, xH::Real=0.752)\n\nGamma-ray emissivity at photon energy Eγ [GeV] for thermal gas with properties rho_cgs [g/cm^3] and T_K [K]. Sets up a CR proton spectrum with energy slope α_p as a fraction Xcr of the thermal energy density. Returns emissivity in units [GeV cm^-3 s^-1 ]. See Pfrommer&Enßlin (2004), Eq. 19.\n\nFunction Arguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nEγ: Photon energy [GeV]\nXcr: CR proton to thermal pressure ratio.\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nFor mean value along line-of-sight:\n\nweights: rho (weight with density)\nreduce_image: true\n\nFor integral along line-of-sight, aka surface brightness:\n\nweights: part_weight_physical\nreduce_image: false\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.kinetic_SZ","page":"API reference","title":"SPHtoGrid.kinetic_SZ","text":"kinetic_SZ(n_cm3::Real, vel_y_cgs::Real, \n           z::Real=0.0, ν::Real=1.e9;\n           DI_over_I::Bool=false)\n\nComputes the kinetic Sunyaev-Zel'dovich effect from electron density n_cm3 and velocity in y-direction to the projection plane in cgs units vel_y_cgs. If DI_over_I is set to true you also need to provide an observation frequency ν and redshift z.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nvel_y_cgs: SPH particle velocity in y-direction in [cm/s]\nz: Redshift\nν: Observing frequency\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.map_it","page":"API reference","title":"SPHtoGrid.map_it","text":"map_it(pos_in, hsml, mass, rho, bin_q, weights, RM=nothing;\n       param::mappingParameters,\n       kernel::AbstractSPHKernel=WendlandC6(2), \n       snap::Integer=0, \n       units::AbstractString=\"\", \n       image_prefix::String=\"dummy\",\n       reduce_image::Bool=true, \n       parallel=true,\n       calc_mean::Bool=true, show_progress::Bool=true,\n       sort_z::Bool=false,\n       stokes::Bool=false,\n       projection=\"xy\")\n\nSmall helper function to copy positions, map particles and save the fits file.\n\nArguments\n\npos_in: Matrix (3xNpart) with particle positions\nhsml: Array with particle hsml\nmass: Array with particle masses\nrho: Array with particle densities\nbin_q: Array with particle quantity to be mapped\nweights: Array with weights. Defaults to density-weighted\nparam: mappingParameters for this map\nkernel: AbstractSPHKernel to be used for mapping\nunits: Unit string will be saved to FITS file\nimage_prefix: Name of the file to save, withou .fits file-ending\nreduce_image: If weights need to be applied or not. Set to false for part_weight_physical\nparallel: Run on multiple processors.\ncalc_mean: Calculates the mean value along the line of sight. If set to false the particle only contributes if its bin_q is larger than 0.\nshow_progress: Show progress bar\nsort_z: Sort the particles according to their line-of-sight direction. Needed for polarisation mapping.\nstokes: Set to true of you are mapping Stokes parameters to account for Faraday rotation of the polarisation angle.\nprojection: Which plane the position should be rotated in. Can also be an Array of 3 Euler angles (in [°]) (not used yet!)\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.part_weight_XrayBand","page":"API reference","title":"SPHtoGrid.part_weight_XrayBand","text":"part_weight_XrayBand(T_K::Array{<:Real}, Emin::Real, Emax::Real)\n\nComputes Xray weighted emission of a defined energy band. Emin and Emax are energies in eV.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.part_weight_emission-Tuple{Array{<:Real}, Array{<:Real}}","page":"API reference","title":"SPHtoGrid.part_weight_emission","text":"part_weight_emission(rho::Array{<:Real}, T_K::Array{<:Real})\n\nEmission weighted mapping. Takes density in internal untis and temperature in K and computes weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.part_weight_one-Tuple{Integer}","page":"API reference","title":"SPHtoGrid.part_weight_one","text":"part_weight_one(N::Integer)\n\nEquivalent to no weighting. Returns an Array of ones.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.part_weight_physical","page":"API reference","title":"SPHtoGrid.part_weight_physical","text":"part_weight_physical(N::Integer, par::mappingParameters, x_cgs::Real=3.085678e21)\n\nPhysical weighting function in units of [cm/pix].  To be used with sphMapping.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.part_weight_physical-2","page":"API reference","title":"SPHtoGrid.part_weight_physical","text":"part_weight_physical(N::Integer, x_cgs::Real=3.085678e21)\n\nPhysical weighting function in units of [cm].      To be used with healpix_map.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.part_weight_spectroscopic-Tuple{Array{<:Real}, Array{<:Real}}","page":"API reference","title":"SPHtoGrid.part_weight_spectroscopic","text":"part_weight_spectroscopic(rho::Array{<:Real}, T_K::Array{<:Real})\n\nSpectroscopic weighted mapping from Mazotta+ 04. Takes density and temperature and computes weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.polarisation_angle","page":"API reference","title":"SPHtoGrid.polarisation_angle","text":"polarisation_angle(Q_image, U_image, Iν_image=nothing, Iν_cutoff= 0.0)\n\nCompute the polarisation fraction image from Stokes Q and U images.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.polarisation_fraction","page":"API reference","title":"SPHtoGrid.polarisation_fraction","text":"polarisation_fraction(Q_image, U_image, Iν_image, Iν_cutoff= 0.0)\n\nCompute the polarisation fraction image from Stokes Q and U images.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.project_along_axis","page":"API reference","title":"SPHtoGrid.project_along_axis","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.project_along_axis!","page":"API reference","title":"SPHtoGrid.project_along_axis!","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.project_along_axis!-2","page":"API reference","title":"SPHtoGrid.project_along_axis!","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.read_allsky_fits_image-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_allsky_fits_image","text":"read_allsky_fits_image(filename::String)\n\nRead a FITS file containing an allsky image and returns the image, snapshot number and units.\n\nReturns\n\nimage: A 2D array with the image pixels \nsnap:  Number of the mapped snapshot\nunits: A unit string of the image\n\nExample\n\nimage, snapnr, unitstring = readallskyfits_image(filename)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_fits_image","page":"API reference","title":"SPHtoGrid.read_fits_image","text":"read_fits_image(filename::String)\n\nRead a FITS file and return the image, mappingParameters and the snapshot number.\n\nReturns\n\nimage: A 2D array with the image pixels \npar:   mappingParameters used for the image \nsnap:  Number of the mapped snapshot\nunits: A unit string of the image\n\nExample\n\nimage, par, snapnr, unitstring = readfitsimage(filename)\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.read_smac1_binary_image-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_smac1_binary_image","text":"read_smac1_binary_image(filename::String)\n\nReads a binary image file from Smac and returns a Matrix with the pixel values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_smac1_binary_info-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_smac1_binary_info","text":"read_smac1_binary_info(filename::String)\n\nReturns the image info in a Smac1ImageInfo struct.\n\nSmac1ImageInfo fields\n\nsnap::Int32:             number of input snapshot\nz::Float32:              redshift of snapshot\nm_vir::Float32:          virial mass of halo\nr_vir::Float32:          virial radius of halo\nxcm::Float32:            x coordinate of image center\nycm::Float32:            y coordinate of image center\nzcm::Float32:            z coordinate of image center\nz_slice_kpc::Float32:    depth of the image in kpc\nboxsize_kpc::Float32:    xy-size of the image in kpc\nboxsize_pix::Float32:    xy-size of the image in pixels\npixsize_kpc::Float32:    size of one pixel in kpc\nxlim::Array{Float64,1}:  x limits of image\nylim::Array{Float64,1}:  y limits of image\nzlim::Array{Float64,1}:  z limits of image\nunits::String:           unitstring of image\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_smac1_fits_image","page":"API reference","title":"SPHtoGrid.read_smac1_fits_image","text":"read_smac1_fits_image(filename::String)\n\nReturns the image of a Smac1 FITS file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.read_smac1_fits_info-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_smac1_fits_info","text":"read_smac1_fits_info(filename::String)\n\nReturns the image info in a mappingParameters struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_smac2_image","page":"API reference","title":"SPHtoGrid.read_smac2_image","text":"read_smac2_image(filename::String)\n\nReturns the image of a Smac2 FITS file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.read_smac2_info-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_smac2_info","text":"read_smac2_info(filename::String)\n\nReturns the image info in a mappingParameters struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_3D!-Tuple{Array{<:Real}, Real, Real, Real}","page":"API reference","title":"SPHtoGrid.rotate_3D!","text":"rotate_3D!(x::Array{<:Real}, alpha::Real, beta::Real, gamma::Real)\n\nRotates and array of 3D positions around the euler angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively. α, β and γ need to be given in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_3D-Tuple{Array{<:Real}, Real, Real, Real}","page":"API reference","title":"SPHtoGrid.rotate_3D","text":"rotate_3D(x::Array{<:Real}, alpha::Real, beta::Real, gamma::Real)\n\nRotates and array of 3D positions around the euler angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively. α, β and γ need to be given in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotation_measure-Tuple{Real, Real, Real}","page":"API reference","title":"SPHtoGrid.rotation_measure","text":"rotation_measure(n_cm3::Real, B_los::Real, dz::Real; ν_obs=nothing)\n\nComputes the rotation measure of the parallel magnetic field along the LOS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.sphMapping","page":"API reference","title":"SPHtoGrid.sphMapping","text":"sphMapping( Pos::Array{<:Real}, HSML::Array{<:Real}, M::Array{<:Real}, \n            Rho::Array{<:Real}, Bin_Quant::Array{<:Real}, \n            Weights::Array{<:Real}=Rho;\n            param::mappingParameters,\n            kernel::AbstractSPHKernel,\n            show_progress::Bool=true,\n            parallel::Bool=false,\n            reduce_image::Bool=true,\n            return_both_maps::Bool=false,\n            filter_particles::Bool=true,\n            dimensions::Int=2,\n            calc_mean::Bool=false)\n\nMaps the data in Bin_Quant to a grid. Parameters of mapping are supplied in param and the kernel to be used in kernel.\n\nArguments\n\nPos: Matrix (3xNpart) with particle positions\nHSML: Array with particle hsml\nM: Array with particle masses\nRho: Array with particle densities\nBin_Quant: Array with particle quantity to be mapped\nWeights: Array with weights. Defaults to density-weighted\nparam: mappingParameters for this map\nkernel: AbstractSPHKernel to be used for mapping\nshow_progress: Show progress bar\nparallel: Run on multiple processors\nreduce_image: If weights need to be applied or not. Set to false for part_weight_physical\nreturn_both_maps: Returns the full image array. To be used with parallel mapping of subfiles\nfilter_particles: Find the particles that are actually contained in the image\ndimensions: Number of mapping dimensions (2 = to grid, 3 = to cube)\ncalc_mean: Calculates the mean value along the line of sight. If set to false the particle only contributes if its Bin_Quant is larger than 0\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.sphMapping-Tuple{Matrix{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"API reference","title":"SPHtoGrid.sphMapping","text":"sphMapping( Pos, HSML, Bin_Quant;\n            param::mappingParameters,\n            kernel::AbstractSPHKernel,\n            show_progress::Bool=true,\n            parallel::Bool=false,\n            reduce_image::Bool=true,\n            filter_particles::Bool=true,\n            dimensions::Int=2)\n\nMaps the data in Bin_Quant to a grid. Parameters of mapping are supplied in param and the kernel to be used in kernel.\n\nArguments\n\nPos: Matrix (3xNpart) with particle positions.\nHSML: Array with particle hsml.\nBin_Quant: Array with particle quantity to be mapped.\nkernel::AbstractSPHKernel: Kernel object to be used.\nshow_progress::Bool=true: Show progress bar.\nparallel::Bool=true: Run on multiple processors.\nreduce_image::Bool=true: If weights need to be applied or not. Set to false for part_weight_one and part_weight_physical.\nfilter_particles::Bool=true: Find the particles that are actually contained in the image.\ndimensions::Int=2: Number of mapping dimensions (2 = to grid, 3 = to cube).\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.surface_brightness_to_luminosity-Tuple{Matrix{<:Real}, Real}","page":"API reference","title":"SPHtoGrid.surface_brightness_to_luminosity","text":"surface_brightness_to_luminosity(map::Matrix{<:Real}, pixelSideLength::Real; unit_factor::Real=1.0)\n\nConverts a map of surface brightness to luminosity per pixel. Uses pixelSideLength as the diameter of a pixel in [kpc]. If unit_factor is provided it is multiplied to every pixel to perform unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.surface_brightness_to_luminosity-Tuple{Matrix{<:Real}, mappingParameters}","page":"API reference","title":"SPHtoGrid.surface_brightness_to_luminosity","text":"surface_brightness_to_luminosity(map::Matrix{<:Real}, par::mappingParameters; unit_factor::Real=1.0)\n\nConverts a map of surface brightness to luminosity per pixel. If unit_factor is provided it is multiplied to every pixel to perform unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.synchrotron_SB_to_luminosity-Tuple{Matrix{<:Real}, Real}","page":"API reference","title":"SPHtoGrid.synchrotron_SB_to_luminosity","text":"synchrotron_SB_to_luminosity(map, pixelSideLength::Real)\n\nConverts a map of synchrotron surface brightness [erg/s/Hz/cm^2] to synchrotron luminosity [W/Hz]. Uses pixelSideLength as the diameter of a pixel in [kpc].\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.synchrotron_SB_to_luminosity-Tuple{Matrix{<:Real}, mappingParameters}","page":"API reference","title":"SPHtoGrid.synchrotron_SB_to_luminosity","text":"synchrotron_SB_to_luminosity(map, par::mappingParameters)\n\nConverts a map of synchrotron surface brightness [erg/s/Hz/cm^2] to synchrotron luminosity [W/Hz]. Uses par as the mappingParameters of the original map.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.thermal_SZ","page":"API reference","title":"SPHtoGrid.thermal_SZ","text":"thermal_SZ( n_cm3::Vector{<:Real}, T_K::Vector{<:Real},\n            z::Real=0.0, ν::Real=1.44e9; \n            DI_over_I::Bool=false )\n\nComputes the thermal Sunyaev-Zel'dovich effect for electron density n_cm3 and temperature T_K in Kelvin at redshift z and observer frequency ν. DI_over_I outputs in units of dII if set to true and dT/T otherwise.\n\nArguments:\n\nn_cm3: SPH particle density in [1/cm^3]\nT_K: SPH particle temperature [K]\nz: Redshift\nν: Observing frequency\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.total_synch_luminosity_from_SB-Tuple{Matrix{<:Real}, Real}","page":"API reference","title":"SPHtoGrid.total_synch_luminosity_from_SB","text":"total_synch_luminosity_from_SB(map::Matrix{<:Real}, pixelSideLength::Real)\n\nComputes the total synchrotron luminosity in [W/Hz] from a map of synchrotron surface brightness in [erg/s/Hz/cm^2].\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.total_synch_luminosity_from_SB-Tuple{Matrix{<:Real}, mappingParameters}","page":"API reference","title":"SPHtoGrid.total_synch_luminosity_from_SB","text":"total_synch_luminosity_from_SB(map::Matrix{<:Real}, par::mappingParameters)\n\nComputes the total synchrotron luminosity in [W/Hz] from a map of synchrotron surface brightness in [erg/s/Hz/cm^2].\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.total_synch_luminosity_from_SB-Tuple{String}","page":"API reference","title":"SPHtoGrid.total_synch_luminosity_from_SB","text":"total_synch_luminosity_from_SB(filename::String)\n\nComputes the total synchrotron luminosity in [W/Hz] from a map of synchrotron surface brightness in [erg/s/Hz/cm^2].\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.write_fits_image-Tuple{String, Array{<:Real}, mappingParameters}","page":"API reference","title":"SPHtoGrid.write_fits_image","text":"write_fits_image(filename::String, image::Array{<:Real}, \n                        par::mappingParameters; \n                        units::String=\"[i.u.]\",\n                        snap::Integer=0)\n\nWrites a mapped image to a FITS file and stored the essential mapping parameters in the header.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.write_fits_image-Tuple{String, Array{<:Real}}","page":"API reference","title":"SPHtoGrid.write_fits_image","text":"write_fits_image(filename::String, image::Array{<:Real};\n                units::String = \"[i.u.]\",\n                snap::Integer = 0)\n\nWrites a mapped allsky image to a FITS file and stored units and snapshot number in the header.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.write_smac1_par","page":"API reference","title":"SPHtoGrid.write_smac1_par","text":"write_smac1_par( path=\"./\"; kwargs...)\n\nWrites a Smac parameter file. Add keyword arguments according to the smac1 parameter file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.write_smac2_par","page":"API reference","title":"SPHtoGrid.write_smac2_par","text":"write_smac2_par(x, y, z,\n                euler_angle_0, euler_angle_1, euler_angle_2,\n                xy_size, z_depth, xy_pix::Integer,\n                input_file, output_file, path,\n                effect_module::Integer=0, effect_flag::Integer=0,\n                ν_obs::Real=1.44e9, cosmology::Integer=0,\n                CR_pmin::Real=10.0, CR_pmax::Real=1.e7)\n\nWrites a P-Smac2 parameter file. Not all relevant parameters implemented yet!\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.x_ray_emissivity","page":"API reference","title":"SPHtoGrid.x_ray_emissivity","text":"x_ray_emissivity(T_keV::Vector{<:Real}, \n                 rho_cgs::Vector{<:Real},\n                 metalicity::Union{Vector{Float64, Nothing}}=nothing; \n                 E0::Real=0.1, E1::Real=2.4, \n                 xH::Real=0.752,\n                 cooling_function::Bool=false,\n                 z::Real=0.0)\n\nX-Ray emissivity for particles with temperature T_keV in keV, and density rho_cgs in gcm^3. If available you can also add the metalicity in the gas. Emin and Emax give the minimum and maximum energy of the oberservation. xH gives the hydrogen fraction used in the simulation.\n\nReturns\n\nX-Ray emissivity in units of [erg/s/cm^3].\n\nArguments:\n\nT_keV: SPH particle temperature [keV]\nm_cgs: SPH particle mass in [g]\nrho_cgs: SPH particle density in [g/cm^3]\nE0: Minimum photon energy for Xray spectrum [keV]\nE1: Maximum photon energy for Xray spectrum [keV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nweight function: part_weight_physical\nreduce image: false\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.λγ_PE04-Tuple{Real, Real, Real}","page":"API reference","title":"SPHtoGrid.λγ_PE04","text":"λγ_PE04(rho_cgs::Real, T_K::Real, α_p::Real; \n        Xcr::Real=0.5,\n        Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,\n        xH::Real=0.752)\n\nNumber of γ-ray photons produced per time and volume from a proton spectrum given as a fraction Xcr of the energy density defined by rho_cgs [g/cm^3] and T_K [K], with a powerlaw slope in energy α_p. Integrated between photon energies Eγ_π0_min and Eγ_π0_max [GeV]. Returns number of photons in energy band in units of [γ cm^-3 s^-1]. See Pfrommer&Enßlin (2004), Eq. 25.\n\nFunction Arguments:\n\nrho_cgs: SPH particle density in [g/cm^3]\nT_K: SPH particle temperature [K]\nα_p: Slope of proton energy spectrum S ~ 2.0 - 2.5\nXcr: CR proton to thermal pressure ratio.\nEγ_π0_min: Minimum photon energy for γ-ray spectrum [GeV]\nEγ_π0_max: Maximum photon energy for γ-ray spectrum [GeV]\nxH: Hydrogen mass fraction in the simulation\n\nMapping settings\n\nFor mean value along line-of-sight:\n\nweights: rho (weight with density)\nreduce_image: true\n\nFor integral along line-of-sight, aka surface brightness:\n\nweights: part_weight_physical\nreduce_image: false\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHtoGrid.mappingParameters","page":"API reference","title":"SPHtoGrid.mappingParameters","text":"mappingParameters( T::DataType=Float64;\n                   x_lim::Vector{Float64}   = [-1.0, -1.0],\n                   y_lim::Vector{Float64}   = [-1.0, -1.0],\n                   z_lim::Vector{Float64}   = [-1.0, -1.0],\n                   center::Vector{Float64}  = [-1.0, -1.0, -1.0],\n                   x_size::Float64          =  -1.0,\n                   y_size::Float64          =  -1.0,\n                   z_size::Float64          =  -1.0,\n                   pixelSideLength::Float64 =  -1.0,\n                   Npixels::Int64           =   0)\n\nParameter object for sph to grid mapping. Define either *_lim, or center and *_size.  Resolution is defined by pixelSideLength or Npixels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHtoGrid.B_cmb-Tuple{Real}","page":"API reference","title":"SPHtoGrid.B_cmb","text":"B_cmb(z::Real)\n\nMagnetic field equivalent of the CMB for a given redshift z in [G].\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.E_integrant-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"API reference","title":"SPHtoGrid.E_integrant","text":"E_integrant(Eγ::T, δ::T, α_δ::T) where T\n\nHelper function for the Integrand.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.E_γ_powδ-Union{Tuple{T}, Tuple{T, T}} where T","page":"API reference","title":"SPHtoGrid.E_γ_powδ","text":"E_γ_powδ(Eγ::T, δ::T) where T\n\nHelper function for the sum in the Integrand.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.EpsNtherm-Tuple{Real, Real}","page":"API reference","title":"SPHtoGrid.EpsNtherm","text":"EpsNtherm(rho_cgs::Real, T_K::Real)\n\nThermal energy density in cgs.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.Tcmb-Tuple{Real}","page":"API reference","title":"SPHtoGrid.Tcmb","text":"Tcmb(z::Real)\n\nComputes the temperature of the CMB at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.X_cr-Tuple{Real, Real}","page":"API reference","title":"SPHtoGrid.X_cr","text":"X_cr(Mach::Real, ξ::Real)\n\nRatio between CR and thermal pressure for an injected CR spectrum following Pfrommer et. al. (2017). Uses the assumption that the CRs do not significantly alter the shock properties, which is not valid in the case of efficient CR proton injection!\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.add_subtr_box-Union{Tuple{T}, Tuple{T, T}} where T","page":"API reference","title":"SPHtoGrid.add_subtr_box","text":"add_subtr_box(pos::T, boxsize::T) where T\n\nHelper function to add or subtract the boxsize from the given position\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_index-Union{Tuple{T}, NTuple{5, T}} where T","page":"API reference","title":"SPHtoGrid.calculate_index","text":"function calculate_index(i::Integer, j::Integer, x_pixels::Integer)\n\nCalculates the index of a flattened 3D image array.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_index-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"API reference","title":"SPHtoGrid.calculate_index","text":"function calculate_index(i::Integer, j::Integer, x_pixels::Integer)\n\nCalculates the index of a flattened 2D image array.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights-Tuple{Vector{Float64}, Vector{Float64}, Integer, Integer, Integer, Integer, Real, Real, Real, Real, SPHKernels.AbstractSPHKernel, Integer}","page":"API reference","title":"SPHtoGrid.calculate_weights","text":"function calculate_weights_2D(  wk::Array{<:Real,1}, \n                                iMin::Integer, iMax::Integer, \n                                jMin::Integer, jMax::Integer,\n                                x::Real, y::Real, hsml::Real, hsml_inv::Real,\n                                kernel::AbstractSPHKernel,\n                                x_pixels::Integer )\n\nCalculates the kernel- and geometric weights of the pixels a particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{Float64}, Integer, Integer, Integer, Integer, Integer, Integer, T, T, T, T, T, SPHKernels.AbstractSPHKernel, Integer, Integer}} where T","page":"API reference","title":"SPHtoGrid.calculate_weights","text":"function calculate_weights_3D(  wk::Array{<:Real,1}, \n                                iMin::Integer, iMax::Integer, \n                                jMin::Integer, jMax::Integer,\n                                kMin::Integer, kMax::Integer,\n                                x::Real, y::Real, z::Real, \n                                hsml::Real, hsml_inv::Real,\n                                kernel::AbstractSPHKernel,\n                                x_pixels::Integer, y_pixels::Integer )\n\nCalculates the kernel- and geometric weights of the pixels a particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, T, Healpix.Resolution, Vector{Int64}, T, SPHKernels.AbstractSPHKernel}} where T","page":"API reference","title":"SPHtoGrid.calculate_weights","text":"calculate_weights(wk::Vector{Float64}, A::Vector{Float64}, \n                _pos::Vector{Float64}, _hsml::Float64,\n                _Δx::Float64, res::Resolution,\n                pixidx::Vector{Int64}, ang_pix::Float64,\n                kernel::AbstractSPHKernel)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights_splash-Tuple{Vector{Float64}, Integer, Integer, Integer, Integer, Real, Real, Real, Real, SPHKernels.AbstractSPHKernel, Integer}","page":"API reference","title":"SPHtoGrid.calculate_weights_splash","text":"function calculate_weights_2D(  wk::Array{<:Real,1}, \n                                iMin::Integer, iMax::Integer, \n                                jMin::Integer, jMax::Integer,\n                                x::Real, y::Real, hsml::Real, hsml_inv::Real,\n                                kernel::AbstractSPHKernel,\n                                x_pixels::Integer )\n\nCalculates the kernel- and geometric weights of the pixels a particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights_splash-Union{Tuple{T}, Tuple{Vector{Float64}, Integer, Integer, Integer, Integer, Integer, Integer, T, T, T, T, T, SPHKernels.AbstractSPHKernel, Integer, Integer}} where T","page":"API reference","title":"SPHtoGrid.calculate_weights_splash","text":"function calculate_weights_3D(  wk::Array{<:Real,1}, \n                                iMin::Integer, iMax::Integer, \n                                jMin::Integer, jMax::Integer,\n                                kMin::Integer, kMax::Integer,\n                                x::Real, y::Real, z::Real, \n                                hsml::Real, hsml_inv::Real,\n                                kernel::AbstractSPHKernel,\n                                x_pixels::Integer, y_pixels::Integer )\n\nCalculates the kernel- and geometric weights of the pixels a particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.center_particles-Union{Tuple{T}, Tuple{Matrix{T}, mappingParameters}} where T","page":"API reference","title":"SPHtoGrid.center_particles","text":"center_particles(x, par::mappingParameters)\n\nShifts all particles so that the image is centered on [0, 0, 0].\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.cic_mapping_2D","page":"API reference","title":"SPHtoGrid.cic_mapping_2D","text":"cicmapping2D( Pos, HSML, M, Rho, BinQ, Weights;                    param::mappingParameters,                     kernel::AbstractSPHKernel,                    showprogress::Bool=false,                    calc_mean::Bool=true )\n\nUnderlying function to map SPH data to a 2D grid.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.contributing_area-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"API reference","title":"SPHtoGrid.contributing_area","text":"contributing_area(dx, hsml, ang_pix)\n\nCalculates the area of the pixel the particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.contributing_pixels-Union{Tuple{T}, Tuple{Vector{T}, T, Healpix.Resolution, Any}} where T","page":"API reference","title":"SPHtoGrid.contributing_pixels","text":"contributing_pixels(pos::Vector{T}, radius::T, \n                    res::Resolution, allsky_map) where {T}\n\nComputes the pixels the particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.cre_spec_norm_particle-Union{Tuple{T}, Tuple{DiffusiveShockAccelerationModels.AbstractShockAccelerationEfficiency, T}} where T","page":"API reference","title":"SPHtoGrid.cre_spec_norm_particle","text":"cre_spec_norm_particle(M::Real, η_model::AbstractShockAccelerationEfficiency)\n\nComputes the CR electron norm of the particles.  This depends on the Mach number M and the acceleration efficiency given by η_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.distance_to_pixel_center-Union{Tuple{T}, Tuple{T, Vector{T}, Tuple{T, T, T}}} where T<:Real","page":"API reference","title":"SPHtoGrid.distance_to_pixel_center","text":"distance_to_pixel_center(r::T, pos::Vector{T}, pixel_center::Vector{T}) where T<:Real\n\nCompute the distance between particle vector and pixel center in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.do_work-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.do_work","text":"do_work(jobs, results, f)\n\nDefines the work function f on all processes. \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.domain_decomposition-Tuple{Integer, Integer}","page":"API reference","title":"SPHtoGrid.domain_decomposition","text":"domain_decomposition(N::Int64, N_workers::Int64)\n\nCalculate relevant array slices for each worker. Could be done better!\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.dsa_spectral_index-Tuple{Real}","page":"API reference","title":"SPHtoGrid.dsa_spectral_index","text":"dsa_spectral_index(M::Real)\n\nSpectral index given by standard Diffuse-Shock-Acceleration (DSA).\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.faraday_rotate_pixel!-Tuple{Array{Float64}, Integer, Float64, Float64, Bool}","page":"API reference","title":"SPHtoGrid.faraday_rotate_pixel!","text":"faraday_rotate_pixel!(image::Array{Float64}, idx::Integer, \n                      pRM::Float64, pix_weight::Float64)\n\nFaraday rotates the current pixel state based on the contribution from particle p.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.filter_sort_particles-NTuple{8, Any}","page":"API reference","title":"SPHtoGrid.filter_sort_particles","text":"filter_sort_particles(Pos, Hsml, Bin_q, Weights, center, radius_limits)\n\nFilters the particles that are in the shell that should be mapped and sorts them by according to their position along the line of sight. Returns arrays with only relevant particles\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.find_in_shell-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T","page":"API reference","title":"SPHtoGrid.find_in_shell","text":"find_in_shell(Δx, radius_limits)\n\nChecks if a particle is contained in a shell around \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.find_position_periodic-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.find_position_periodic","text":"find_position_periodic( pos, k, boxsize )\n\nPerforms a periodic mapping of the particle position.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.gamma_source_PE04-NTuple{4, Real}","page":"API reference","title":"SPHtoGrid.gamma_source_PE04","text":"gamma_source_PE04(Eγ::T, f_p::T, q_p::T, nH::T) where {T}\n\nSource function of gamma-ray photons at energy Eγ in units of N_photons erg^-1 s^-1 cm^-3 as given in Pfrommer&Enßlin (2004), Eq.19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_cooling_emissivity-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.get_cooling_emissivity","text":"get_cooling_emissivity(T_keV, rho_cgs, metalicity; E0, E1)\n\nComputes the Xray emissivity from interpolating a cooling table.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_d_hsml-Union{Tuple{T}, NTuple{4, T}} where T","page":"API reference","title":"SPHtoGrid.get_d_hsml","text":"get_d_hsml_3D( dx::Real, dy::Real, dz::Real, hsml_inv::Real )\n\nComputes the distance in 3D to the pixel center in units of the kernel support.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_d_hsml-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"API reference","title":"SPHtoGrid.get_d_hsml","text":"get_d_hsml( dx::Real, dy::Real, hsml_inv::Real )\n\nComputes the distance in 2D to the pixel center in units of the kernel support.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_dxyz-Tuple{Real, Real, Integer}","page":"API reference","title":"SPHtoGrid.get_dxyz","text":"function get_dxyz(x::Real, hsml::Real, i::Integer)\n\nCalculates the extent of the current particle size in units of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_dz-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.get_dz","text":"get_dz(M, rho, hsml)\n\nHelper function to get the particle depth along the LOS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_number_densities-NTuple{5, Real}","page":"API reference","title":"SPHtoGrid.get_number_densities","text":"get_number_densities(rho_cgs::Real, T_K::Real, α_p::Real, Xcr::Real, xH::Real)\n\nThermal proton number density and CR proton normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_quantities_2D-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, T}} where T","page":"API reference","title":"SPHtoGrid.get_quantities_2D","text":"get_quantities_2D( pos, weight, hsml, \n                   rho, m, len2pix::T) where T\n\nHelper function to convert quantities to pixel units and the correct data type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_quantities_3D-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, T}} where T","page":"API reference","title":"SPHtoGrid.get_quantities_3D","text":"get_quantities_3D( pos, weight, hsml, \n                        rho, m, len2pix::T) where T\n\nHelper function to get \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_quantities_splash-Union{Tuple{T}, Tuple{Any, Any, T}} where T","page":"API reference","title":"SPHtoGrid.get_quantities_splash","text":"get_quantities_splash( pos, weight, hsml, \n                   rho, m, len2pix::T) where T\n\nHelper function to convert quantities to pixel units and the correct data type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_synch_emissivity_integral-NTuple{4, Real}","page":"API reference","title":"SPHtoGrid.get_synch_emissivity_integral","text":"\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_weight_per_pixel-NTuple{8, Any}","page":"API reference","title":"SPHtoGrid.get_weight_per_pixel","text":"get_weight_per_pixel(distr_area, distr_weight,\n                            n_tot_pix, n_distr_pix,\n                            dxdy, u, hsml_inv,\n                            kernel)\n\nComputes the area/volume contribution for each pixel and evaluates the kernel at the pixel center.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_x_dx-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.get_x_dx","text":"function get_x_dx(x, hsml, i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_xs-Tuple{Any}","page":"API reference","title":"SPHtoGrid.get_xs","text":"get_xs(M)\n\nShock compression ratio in the ideal hydrodynamical case.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_xyz-Union{Tuple{T}, Tuple{Array{T}, mappingParameters}} where T","page":"API reference","title":"SPHtoGrid.get_xyz","text":"function get_xyz( pos, hsml, k::Integer,\n                  par::mappingParameters)\n\nCalculates x, y, z position in units of pixels and performs periodic mapping, if required.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.init_Ψ_interpolation-Tuple{}","page":"API reference","title":"SPHtoGrid.init_Ψ_interpolation","text":"init_Ψ_interpolation()\n\nRead the Ψ table and initialize a linear inzerpolation for the values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.integrate_θ","page":"API reference","title":"SPHtoGrid.integrate_θ","text":"integrate_θ(x_in::Real, synch_F::Function, θ_steps::Integer=50)\n\nPitch angle integration in Donnert+16, Eq. 17. synch_F can be either the first or second synchrotron function.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.interpolate_table-Tuple{Any, Any}","page":"API reference","title":"SPHtoGrid.interpolate_table","text":"interpolate_table(Qi, Q_table)\n\nFinds the first position in the provided table where Qi is larger than a table entry.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.kSzPrefac-Tuple{Real, Real, Bool}","page":"API reference","title":"SPHtoGrid.kSzPrefac","text":"kSzPrefac(ν::Real, z::Real, DI_over_I::Bool)\n\nPrefactor for the kinetic Sunyaev-Zel'dovich effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.make_jobs-Tuple{Any}","page":"API reference","title":"SPHtoGrid.make_jobs","text":"make_jobs(n)\n\nStarts up n number of jobs.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.particle_area_and_depth-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"API reference","title":"SPHtoGrid.particle_area_and_depth","text":"particle_area_and_depth(d, hsml, pix_radian)\n\nComputes the particle area and depth. Caution: This has to be represented as a cylinder instead of a sphere, which introduces an error by design. Also computes the pixel radius at the particle horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.particle_in_image-Union{Tuple{T}, Tuple{Real, Real, Real, Array{T}}} where T","page":"API reference","title":"SPHtoGrid.particle_in_image","text":"particle_in_image(x::Real, y::Real, z::Real)\n\nChecks if a periodically mapped particle is still in the image frame.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.particle_in_image-Union{Tuple{T}, Tuple{Real, Real, Real, Real, Array{T}, Real}} where T","page":"API reference","title":"SPHtoGrid.particle_in_image","text":"particle_in_image(x::Real, y::Real, z::Real, hsml::Real,\n                            halfXsize::Real, halfYsize::Real, halfZsize::Real)\n\nChecks if a periodically mapped particle is still in the image frame.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.particle_in_image-Union{Tuple{T}, Tuple{Vector{T}, T, Vector{Float64}, Any}} where T","page":"API reference","title":"SPHtoGrid.particle_in_image","text":"particle_in_image( pos::Array{T}, hsml::T,\n                   halfsize::Array{Float64}) where T\n\nChecks if a periodically mapped particle is still in the image frame.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.pix_index_min_max-Union{Tuple{T}, Tuple{T, T, Int64}} where T","page":"API reference","title":"SPHtoGrid.pix_index_min_max","text":"function pix_index_min_max(x::T, hsml::T, n_pixels::Int64) where T\n\nCalculates the minimum and maximum pixel to which a particle contributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.powerlaw_spectrum-Tuple{Real, Real, Real}","page":"API reference","title":"SPHtoGrid.powerlaw_spectrum","text":"powerlaw_spectrum(E::Real, s::Real, CR_Emin::Real)\n\nInterpolate in powerlaw spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.qγ_PE04-NTuple{4, Real}","page":"API reference","title":"SPHtoGrid.qγ_PE04","text":"qγ_PE04(rho_cgs, T_K, α_p, Eγ; \n        Xcr::Real=0.5, \n        xH=0.752)\n\nGamma-ray sorce function at photon energy Eγ for thermal gas with properties rho_cgs [g/cm^3] and T_K [K]. Sets up a CR proton spectrum with energy slope α_p as a fraction Xcr of the thermal energy density. Returns source function in units [γ cm^-3 s^-1 GeV^-1]. See Pfrommer&Enßlin (2004), Eq. 19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_cooling_tables-Tuple{}","page":"API reference","title":"SPHtoGrid.read_cooling_tables","text":"read_cooling_tables()\n\nReads the cooling tables into Arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.reduce_image_2D-Tuple{Matrix{<:Real}, Int64, Int64, Bool}","page":"API reference","title":"SPHtoGrid.reduce_image_2D","text":"function reduce_image_2D( image::Array{<:Real},\n                          x_pixels::Int64, y_pixels::Int64)\n\nUnflattens an image array to a 2D array of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.reduce_image_2D-Tuple{Vector{<:Real}, Int64, Int64}","page":"API reference","title":"SPHtoGrid.reduce_image_2D","text":"function reduce_image_2D( image::Array{<:Real},\n                          x_pixels::Int64, y_pixels::Int64)\n\nUnflattens an image array to a 2D array of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.reduce_image_3D-Tuple{Matrix{<:Real}, Int64, Int64, Int64}","page":"API reference","title":"SPHtoGrid.reduce_image_3D","text":"function reduce_image_3D( image::Array{<:Real}, w_image::Array{<:Real},\n                                        x_pixels::Int64, y_pixels::Int64, z_pixels::Int64)\n\nUnflattens an image array to a 3D array of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.reduce_image_3D-Tuple{Vector{<:Real}, Int64, Int64, Int64}","page":"API reference","title":"SPHtoGrid.reduce_image_3D","text":"function reduce_image_3D( image::Array{<:Real}, w_image::Array{<:Real},\n                                        x_pixels::Int64, y_pixels::Int64, z_pixels::Int64)\n\nUnflattens an image array to a 3D array of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_xz_plane!-Tuple{Array{<:Real}, Array{<:Real}}","page":"API reference","title":"SPHtoGrid.rotate_to_xz_plane!","text":"rotate_to_xz_plane!(x::Array{<:Real})\n\nRotates an array of 3D positions into the xz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_xz_plane!-Tuple{Array{<:Real}}","page":"API reference","title":"SPHtoGrid.rotate_to_xz_plane!","text":"rotate_to_xz_plane!(x::Array{<:Real})\n\nRotates an array of 3D positions into the xz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_xz_plane-Tuple{mappingParameters}","page":"API reference","title":"SPHtoGrid.rotate_to_xz_plane","text":"rotate_to_xz_plane!(par::mappingParameters)\n\nRotates an array of 3D positions into the xz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_yz_plane!-Tuple{Array{<:Real}, Array{<:Real}}","page":"API reference","title":"SPHtoGrid.rotate_to_yz_plane!","text":"rotate_to_yz_plane(x::Array{<:Real}, x_in::Array{<:Real})\n\nRotates an array of 3D positions into the yz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_yz_plane!-Tuple{Array{<:Real}}","page":"API reference","title":"SPHtoGrid.rotate_to_yz_plane!","text":"rotate_to_yz_plane(x::Array{<:Real})\n\nRotates an array of 3D positions into the yz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_yz_plane-Tuple{mappingParameters}","page":"API reference","title":"SPHtoGrid.rotate_to_yz_plane","text":"rotate_to_yz_plane(par::mappingParameters)\n\nRotates an array of 3D positions into the yz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.select_dsa_model-Tuple{DiffusiveShockAccelerationModels.AbstractShockAccelerationEfficiency}","page":"API reference","title":"SPHtoGrid.select_dsa_model","text":"select_dsa_model(dsa_model::AbstractShockAccelerationEfficiency)\n\nHelper function to assign the self-defined DSA model.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.select_dsa_model-Tuple{Integer}","page":"API reference","title":"SPHtoGrid.select_dsa_model","text":"select_dsa_model(dsa_model::Integer)\n\nHelper function to select the DSA model based on integer values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.solve_synchrotron_function-Tuple{Real, Function, Bool}","page":"API reference","title":"SPHtoGrid.solve_synchrotron_function","text":"solve_synchrotron_function( x::Real, synch_F::Function, \n                            integrate_pitch_angle::Bool)\n\nHelper function for solving the pitch angle integration.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.splash_mapping_2D-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.splash_mapping_2D","text":"splashmapping2D( Pos, HSML,                    M, Rho,                    BinQ;                   param::mappingParameters, kernel::AbstractSPHKernel,                   showprogress::Bool=false )\n\nUnderlying function to map SPH data to a 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.splash_mapping_3D-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.splash_mapping_3D","text":"splashmapping3D( Pos, HSML, BinQ;                   param::mappingParameters, kernel::AbstractSPHKernel,                   showprogress::Bool=false )\n\nUnderlying function to map SPH data to a 3D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.tSzPrefac-Tuple{Real, Real, Bool}","page":"API reference","title":"SPHtoGrid.tSzPrefac","text":"tSzPrefac(ν::Real, z::Real, DI_over_I::Bool)\n\nComputes the prefactor for the thermal Sunyaev-Zel'dovich effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.update_image!-NTuple{11, Any}","page":"API reference","title":"SPHtoGrid.update_image!","text":"update_image!(allsky_map, weight_map, wk,\n            pixidx,\n            area, dz,\n            A, N, weight_per_pix,\n            quantity_weight, bin_quantity)\n\nUpdates the images.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.update_image!-Tuple{Array{Float64}, Integer, Float64, Union{Float64, Vector{Float64}}}","page":"API reference","title":"SPHtoGrid.update_image!","text":"function update_image( image::Real, w_image::Real, \n                       wk::Real, bin_q::Real, \n                       geometry_norm::Real )\n\nApplies the different contributions to the image and the weight image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.update_progress!-Tuple{Any, Any, Any}","page":"API reference","title":"SPHtoGrid.update_progress!","text":"update_progress!(P, show_progress, output_this_worker)\n\nUpdates the progress bar if conditions are met.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.weight_per_index-Union{Tuple{T}, Tuple{T, Vector{T}, T, T, Integer, T, T, Integer, Integer, Any, T, SPHKernels.AbstractSPHKernel}} where T","page":"API reference","title":"SPHtoGrid.weight_per_index","text":"weight_per_index(_Δx, _pos, _hsml, _hsml_inv,\n                _pixidx,\n                distr_area, distr_weight, \n                n_tot_pix, n_distr_pix, \n                res, ang_pix,\n                kernel)\n\nHelper function to compute the weights for one pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.ys_f-Tuple{Real, Real}","page":"API reference","title":"SPHtoGrid.ys_f","text":"ys_f(xs::Real, ξ::Real)\n\nHelper function to get ys (see Pfrommer+2017)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.ñ_crp","page":"API reference","title":"SPHtoGrid.ñ_crp","text":"ñ_crp(rho_cgs::Real, T_K::Real, α_p::Real, Xcr::Real=0.01; \n        xH::Real=0.76)\n\nCR proton normalisation in [1/cm^3]\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.α_γ-Tuple{T} where T","page":"API reference","title":"SPHtoGrid.α_γ","text":"α_γ(slope::T) where T\n\nSlope of γ-ray spectrum as a function of the slope of a proton spectrum in energy space. \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.δ_γ-Tuple{T} where T","page":"API reference","title":"SPHtoGrid.δ_γ","text":"δ_γ(α::T) where T\n\nShape parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.σ_pp-Tuple{T} where T","page":"API reference","title":"SPHtoGrid.σ_pp","text":"σ_pp(α::T) where T\n\nScattering cross-section of proton-proton scatterin in cm^2\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.𝒳_f-Tuple{Real, Real}","page":"API reference","title":"SPHtoGrid.𝒳_f","text":"𝒳_f(xs::Real, ξ::Real)\n\nHelper function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHtoGrid.Smac1ImageInfo","page":"API reference","title":"SPHtoGrid.Smac1ImageInfo","text":"struct Smac1ImageInfo\n\nStores the information in a Smac binary image header.\n\n\n\n\n\n","category":"type"},{"location":"external/#External-Programs","page":"External Programs","title":"External Programs","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"SPHtoGrid.jl provides helper function for two external sph mapping Codes: Smac and P-Smac2.","category":"page"},{"location":"external/#Smac","page":"External Programs","title":"Smac","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"Smac is a SPH mapping Code by Klaus Dolag and others. The implementation is described in Dolag et al. 2005.","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"Smac isn't public unfortunately. So these functions are mainly for my personal use. If you do have access to Smac, here's a reference to what you can do.","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"SPHtoGrid.jl provides some functions to read the FITS and binary output of Smac. To get the binary format you need to set FILE_FORMAT = 1 in the parameter file.","category":"page"},{"location":"external/#Writing-the-parameter-file","page":"External Programs","title":"Writing the parameter file","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"You can write a Smac1 parameter file with","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"write_smac1_par","category":"page"},{"location":"external/#SPHtoGrid.write_smac1_par","page":"External Programs","title":"SPHtoGrid.write_smac1_par","text":"write_smac1_par( path=\"./\"; kwargs...)\n\nWrites a Smac parameter file. Add keyword arguments according to the smac1 parameter file.\n\n\n\n\n\n","category":"function"},{"location":"external/#Reading-image-information","page":"External Programs","title":"Reading image information","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"If you set FILE_HEADER = 1 in the Smac parameter file you can read the information of the image header into a Smac1ImageInfo with:","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"read_smac1_binary_image","category":"page"},{"location":"external/#SPHtoGrid.read_smac1_binary_image","page":"External Programs","title":"SPHtoGrid.read_smac1_binary_image","text":"read_smac1_binary_image(filename::String)\n\nReads a binary image file from Smac and returns a Matrix with the pixel values.\n\n\n\n\n\n","category":"function"},{"location":"external/","page":"External Programs","title":"External Programs","text":"For a Smac1 FITS file you can read the header into a mappingParameters struct with","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"read_smac1_fits_info","category":"page"},{"location":"external/#SPHtoGrid.read_smac1_fits_info","page":"External Programs","title":"SPHtoGrid.read_smac1_fits_info","text":"read_smac1_fits_info(filename::String)\n\nReturns the image info in a mappingParameters struct.\n\n\n\n\n\n","category":"function"},{"location":"external/#Reading-the-image","page":"External Programs","title":"Reading the image","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"The image itself can be read with","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"read_smac1_fits_image\nread_smac1_binary_image","category":"page"},{"location":"external/#SPHtoGrid.read_smac1_fits_image","page":"External Programs","title":"SPHtoGrid.read_smac1_fits_image","text":"read_smac1_fits_image(filename::String)\n\nReturns the image of a Smac1 FITS file.\n\n\n\n\n\n","category":"function"},{"location":"external/#P-Smac2","page":"External Programs","title":"P-Smac2","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"P-Smac2 by Julius Donnert is an advanced mapping code for a multitude of different quantities.","category":"page"},{"location":"external/#Writing-the-parameter-file-2","page":"External Programs","title":"Writing the parameter file","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"To run a mapping and plotting loop from a Julia script you need to update the parameter files on the fly. The function write_smac2_par provides this functionality.","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"write_smac2_par","category":"page"},{"location":"external/#SPHtoGrid.write_smac2_par","page":"External Programs","title":"SPHtoGrid.write_smac2_par","text":"write_smac2_par(x, y, z,\n                euler_angle_0, euler_angle_1, euler_angle_2,\n                xy_size, z_depth, xy_pix::Integer,\n                input_file, output_file, path,\n                effect_module::Integer=0, effect_flag::Integer=0,\n                ν_obs::Real=1.44e9, cosmology::Integer=0,\n                CR_pmin::Real=10.0, CR_pmax::Real=1.e7)\n\nWrites a P-Smac2 parameter file. Not all relevant parameters implemented yet!\n\n\n\n\n\n","category":"function"},{"location":"external/#Reading-image-information-2","page":"External Programs","title":"Reading image information","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"For a Smac1 FITS file you can read the header into a mappingParameters struct with","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"read_smac2_info","category":"page"},{"location":"external/#SPHtoGrid.read_smac2_info","page":"External Programs","title":"SPHtoGrid.read_smac2_info","text":"read_smac2_info(filename::String)\n\nReturns the image info in a mappingParameters struct.\n\n\n\n\n\n","category":"function"},{"location":"external/#Reading-the-image-2","page":"External Programs","title":"Reading the image","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"The image itself can be read with","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"read_smac2_image","category":"page"},{"location":"external/#SPHtoGrid.read_smac2_image","page":"External Programs","title":"SPHtoGrid.read_smac2_image","text":"read_smac2_image(filename::String)\n\nReturns the image of a Smac2 FITS file.\n\n\n\n\n\n","category":"function"},{"location":"healpix/#Mapping-SPH-Data-to-an-allsky-HealPix-map","page":"HealPix maps","title":"Mapping SPH Data to an allsky HealPix map","text":"","category":"section"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"You can also use SPHtoGrid.jl to do allsky projections of your simulations. Here is an example of this for one of the simulations of the LOCALIZATION project (Dolag et. al. 2023) :","category":"page"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"(Image: allsky)","category":"page"},{"location":"healpix/#Single-core-mapping","page":"HealPix maps","title":"Single core mapping","text":"","category":"section"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"You can construct healpix maps on a single core with","category":"page"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"healpix_map","category":"page"},{"location":"healpix/#SPHtoGrid.healpix_map","page":"HealPix maps","title":"SPHtoGrid.healpix_map","text":"healpix_map(Pos, Hsml, M, Rho, Bin_q, Weights;\n            center::Vector{<:Real}=[0.0, 0.0, 0.0],\n            radius_limits::Vector{<:Real}=[0.0, Inf],\n            Nside::Integer=1024,\n            kernel::AbstractSPHKernel,\n            calc_mean::Bool=true\n            show_progress::Bool=true,\n            output_from_all_workers::Bool=false)\n\nCalculate an allsky map from SPH particles. Returns two HealpixMaps: (image, weight_image). To reduce the image afterwards divide image by weight_image. \n\nArguments:\n\nPos: Positions of particles in physical code units\nHSML: hsml of particles in physical code units \nM: Mass of particles in physical code units \nBin_Q: Quantitiy for binning in arb. units\nWeights: Weights for map\ncenter: Position from which projection is looking outwards in physical code units \nradius_limits: Inner and outer radius of the shell that should be mapped\nNside: Nside for healpix map, has to be a power of 2\ncalc_mean: Calculate the mean along the line of sight. If set to false only particles with Bin_Q > 0 contribute to the map.\nshow_progress: Print a progress bar \noutput_from_all_workers: Allow output from multiple workers. If set to false only the main process prints a progress bar.\n\n\n\n\n\n","category":"function"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"Example:","category":"page"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"using GadgetIO, GadgetUnits\nusing SPHtoGrid, SPHKernels\n\n# helper function to get maps\nfunction T_maps_of_file(snap_file)\n\n    # read all data\n    blocks = [\"POS\", \"MASS\", \"HSML\", \"RHO\", \"U\"]\n    data = Dict( block => read_block(snap_file, block, parttype=0) for block ∈ blocks )\n\n    # convert to physical code units\n    h = GadgetIO.read_header(snap_file)\n    GU = GadgetPhysical(h)\n\n    pos = data[\"POS\"] .* GU.x_physical\n    hsml = data[\"HSML\"] .* GU.x_physical\n    rho = data[\"RHO\"] .* GU.rho_physical\n    mass = data[\"MASS\"] .* GU.m_physical\n\n    # convert to cgs units\n    T_K = data[\"U\"] .* GU.T_K\n\n    # define map parameters\n    kernel = WendlandC4(2)\n    Nside = 1024\n\n    # position the observer at the center of the box\n    center = 0.5h.boxsize .* ones(3) .* GU.x_physical\n    # map a 10 Mpc slide at a distance of 5 Mpc\n    radius_limits = [5_000.0, 15_000.0]\n\n    map, w_map = healpix_map(pos, hsml, mass, rho, T_K, rho, show_progress=true;\n        center, kernel, Nside, radius_limits)\n\n    return map, w_map\nend\n\n# run the map making\nallsky, weights = mapping_function()\n\n# reduce the image \n@inbounds for i ∈ eachindex(allsky)\n    if !isnan(weights[i]) && !iszero(weights[i]) && !isinf(weights[i])\n        allsky[i] /= weights[i]\n    end\nend\n\n# save the map\nsaveToFITS(allsky, allsky_filename)","category":"page"},{"location":"healpix/#Multi-core-mapping","page":"HealPix maps","title":"Multi core mapping","text":"","category":"section"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"Usually these allsky maps are performed over whole boxes that may consist of multiple sub-snapshots. To allow for a parallel execution there's a helper function","category":"page"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"distributed_allsky_map","category":"page"},{"location":"healpix/#SPHtoGrid.distributed_allsky_map","page":"HealPix maps","title":"SPHtoGrid.distributed_allsky_map","text":"distributed_allsky_map( allsky_filename::String, \n                        Nside::Integer, Nsubfiles::Integer, \n                        mapping_function::Function;\n                        reduce_image::Bool=true)\n\nDynamically dispatches workers to compute one allsky map per subfile, sum up the results and save to a fits file.\n\nArguments\n\nallsky_filename::String: Name of the file under which the image should be saved\nNside::Integer: Nside for healpix map, must be a power of 2! Nside = 2^N.\nNsubfiles::Integer: Number of subfiles the snapshot is distributed over.\nmapping_function::Function: The function to be executed per subfile. Must have a call to allsky_map as return value.\nreduce_image: If the final image should be divided by the weight image set to true\n\n\n\n\n\n","category":"function"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"Example:","category":"page"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"# we run this example on a SLURM cluster\nusing Distributed, ClusterManagers\naddprocs_slurm(parse(Int64, ENV[\"SLURM_NTASKS\"]))\n\n@everywhere using GadgetIO, GadgetUnits\n@everywhere using SPHKernels, SPHtoGrid\n@everywhere using Base.Threads\n\n# helper function for the mapping\n@everywhere function T_maps_of_subfile(subfile)\n\n    println(\"T: subfile $subfile running on $(nthreads()) threads\")\n    flush(stdout); flush(stderr)\n\n    # read data and convert units\n    h = GadgetIO.read_header(snap_file)\n    GU = GadgetPhysical(h)\n\n    hsml = read_block(snap_base * \".$subfile\", \"HSML\", parttype=0) .* GU.x_physical\n    rho = read_block(snap_base * \".$subfile\", \"RHO\", parttype=0) .* GU.rho_physical\n    mass = read_block(snap_base * \".$subfile\", \"RHO\", parttype=0) .* GU.rho_physical\n    T_K   = read_block(snap_base * \".$subfile\", \"U\", parttype=0) .* GU.T_K\n    pos  = read_block(snap_base * \".$subfile\", \"POS\", parttype=0) .* GU.x_physical\n\n    # define map parameters\n    kernel = WendlandC4(2)\n    Nside = 1024\n\n    # position the observer at the center of the box\n    center = 0.5h.boxsize .* ones(3) .* GU.x_physical\n    # map a 10 Mpc slide at a distance of 5 Mpc\n    radius_limits = [5_000.0, 15_000.0]\n\n    # run the mapping\n    allsky, weights  = healpix_map(pos, hsml, mass, rho, T_K, rho, show_progress=true; \n                        center, kernel, Nside, radius_limits)\n\n    # important! de-allocate data to avoid memory overflow!\n    pos = nothing\n    hsml = nothing\n    rho = nothing\n    mass = nothing\n    T_K = nothing\n    kernel = nothing\n    Nside = nothing\n    center = nothing\n    radius_limits = nothing\n    # manually run garbage collector\n    GC.gc()\n\n    # return map\n    return allsky, weights\nend\n\nNside = 1024\nNsubfiles = 1024\nfilename = \"T_allsky.fits\"\n\n# this function takes care of mapping, image reduction\ndistributed_allsky_map(filename, Nside, Nsubfiles, T_maps_of_subfile, reduce_image=true)","category":"page"},{"location":"healpix/#Comparison-to-Smac","page":"HealPix maps","title":"Comparison to Smac","text":"","category":"section"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"As a reference for the mapping we use Smac (Dolag et al. 2005). You can see the comparison with the relative error in the following images. Please note that the bulk of the error in the density weighted map stems from a slightly different calculation of the temperature.","category":"page"},{"location":"healpix/","page":"HealPix maps","title":"HealPix maps","text":"Line-of-sight integration Density weighted\n(Image: rho_allsky) (Image: T_allsky)","category":"page"},{"location":"mapping/#Mapping-SPH-Data-to-Cartesian-Grids","page":"Mapping SPH Data","title":"Mapping SPH Data to Cartesian Grids","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"CurrentModule = SPHtoGrid\nDocTestSetup = quote\n    using SPHtoGrid\nend","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Mapping SPH particles to a grid instead of simply plotting color-coded particle positions shows the actual gas quantities as they are used in an SPH code: weighted with a kernel, according to their distance to each other. You can see this in the following plot, left are color-coded particle positions, right is the mean density in the SPH particles along the line of sight, interpolated to a grid.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"(Image: galaxy)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"You can map SPH data to a grid using the function sphMapping, which comes in two flavors: CIC and TSC.","category":"page"},{"location":"mapping/#Define-parameters-for-mapping","page":"Mapping SPH Data","title":"Define parameters for mapping","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"To map the data you need to define the mapping parameters via the mappingParameters struct.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"mappingParameters","category":"page"},{"location":"mapping/#SPHtoGrid.mappingParameters","page":"Mapping SPH Data","title":"SPHtoGrid.mappingParameters","text":"mappingParameters( T::DataType=Float64;\n                   x_lim::Vector{Float64}   = [-1.0, -1.0],\n                   y_lim::Vector{Float64}   = [-1.0, -1.0],\n                   z_lim::Vector{Float64}   = [-1.0, -1.0],\n                   center::Vector{Float64}  = [-1.0, -1.0, -1.0],\n                   x_size::Float64          =  -1.0,\n                   y_size::Float64          =  -1.0,\n                   z_size::Float64          =  -1.0,\n                   pixelSideLength::Float64 =  -1.0,\n                   Npixels::Int64           =   0)\n\nParameter object for sph to grid mapping. Define either *_lim, or center and *_size.  Resolution is defined by pixelSideLength or Npixels.\n\n\n\n\n\n","category":"type"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"One way to set this up is by defining the limits of the map as","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"par = mappingParameters(xlim=[xmin, xmax],\n                        ylim=[ymin, ymax],\n                        zlim=[zmin, zmax],\n                        Npixels=200)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"or give a center position and the size in each direction","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"par = mappingParameters(center=[x0, y0, z0], \n                        x_size=x_size, \n                        y_size=y_size,\n                        z_size=z_size,\n                        Npixels=200)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Instead of Npixels you can also give the keyword argument pixelSideLength if you prefer to define your image that way.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"If you are mapping a periodic box you also can give the keyword boxsize to enable periodic mapping.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"par = mappingParameters(center=[x0, y0, z0], \n                        x_size=x_size, \n                        y_size=y_size,\n                        z_size=z_size,\n                        boxsize=boxsize,\n                        Npixels=200)","category":"page"},{"location":"mapping/#CIC","page":"Mapping SPH Data","title":"CIC","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"For \"Counts in Cell\" (CIC) interpolation use the function sphMapping with these input values:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"sphMapping(::Array{<:Real}, ::Array{<:Real}, ::Array{<:Real}, ::Array{<:Real}, ::Array{<:Real})","category":"page"},{"location":"mapping/#SPHtoGrid.sphMapping-Tuple{Array{<:Real}, Array{<:Real}, Array{<:Real}, Array{<:Real}, Array{<:Real}}","page":"Mapping SPH Data","title":"SPHtoGrid.sphMapping","text":"sphMapping( Pos::Array{<:Real}, HSML::Array{<:Real}, M::Array{<:Real}, \n            Rho::Array{<:Real}, Bin_Quant::Array{<:Real}, \n            Weights::Array{<:Real}=Rho;\n            param::mappingParameters,\n            kernel::AbstractSPHKernel,\n            show_progress::Bool=true,\n            parallel::Bool=false,\n            reduce_image::Bool=true,\n            return_both_maps::Bool=false,\n            filter_particles::Bool=true,\n            dimensions::Int=2,\n            calc_mean::Bool=false)\n\nMaps the data in Bin_Quant to a grid. Parameters of mapping are supplied in param and the kernel to be used in kernel.\n\nArguments\n\nPos: Matrix (3xNpart) with particle positions\nHSML: Array with particle hsml\nM: Array with particle masses\nRho: Array with particle densities\nBin_Quant: Array with particle quantity to be mapped\nWeights: Array with weights. Defaults to density-weighted\nparam: mappingParameters for this map\nkernel: AbstractSPHKernel to be used for mapping\nshow_progress: Show progress bar\nparallel: Run on multiple processors\nreduce_image: If weights need to be applied or not. Set to false for part_weight_physical\nreturn_both_maps: Returns the full image array. To be used with parallel mapping of subfiles\nfilter_particles: Find the particles that are actually contained in the image\ndimensions: Number of mapping dimensions (2 = to grid, 3 = to cube)\ncalc_mean: Calculates the mean value along the line of sight. If set to false the particle only contributes if its Bin_Quant is larger than 0\n\n\n\n\n\n","category":"method"},{"location":"mapping/#Select-Kernel","page":"Mapping SPH Data","title":"Select Kernel","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"You also need to choose the kernel you used in the simulation. For this you need to install the package SPHKernels.jl. You can currently use these kernels:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"k = Cubic()\nk = Quintic()\nk = WendlandC4()\nk = WendlandC6()\nk = WendlandC8()","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Please see the SPHKernels docs for more details.","category":"page"},{"location":"mapping/#Mapping","page":"Mapping SPH Data","title":"Mapping","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"With the setup done you can now map (e.g.) density of your data using the function above as:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"image = sphMapping(x, hsml, m, rho, rho, param=par, kernel=k)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Replacing the second rho with any other quantity would map that quantity of course. Please note: This function doesn't do any unit conversion for you, so you need to convert to the desired units beforehand. You can do this e.g. with GadgetUnits.jl.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Image now contains a 2D array with the binned data and can easily be plotted with imshow() from any plotting package of your choosing.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"The keyword parallel = true causes the run to use multiple processors. For this you need to start julia with julia -p <N> where <N> is the number of processors in your machine, or define","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"using Distributed\naddprocs(8)\n\n# now you can load SPHtoGrid\nusing SPHtoGrid","category":"page"},{"location":"mapping/#Conserved-quantities","page":"Mapping SPH Data","title":"Conserved quantities","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Particles are mapped to a grid while also conserving the particle volume, following the algorithm described in Dolag et. al. 2006.","category":"page"},{"location":"mapping/#Weight-functions","page":"Mapping SPH Data","title":"Weight functions","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"With the mapping you may decide to use a specific weighting function. For this you can pass the optional variable Weights in sphMapping.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"You can either use your own weight functions or use one of the built-in ones:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"part_weight_one\npart_weight_physical\npart_weight_emission\npart_weight_spectroscopic\npart_weight_XrayBand","category":"page"},{"location":"mapping/#SPHtoGrid.part_weight_one","page":"Mapping SPH Data","title":"SPHtoGrid.part_weight_one","text":"part_weight_one(N::Integer)\n\nEquivalent to no weighting. Returns an Array of ones.\n\n\n\n\n\n","category":"function"},{"location":"mapping/#SPHtoGrid.part_weight_physical","page":"Mapping SPH Data","title":"SPHtoGrid.part_weight_physical","text":"part_weight_physical(N::Integer, par::mappingParameters, x_cgs::Real=3.085678e21)\n\nPhysical weighting function in units of [cm/pix].  To be used with sphMapping.\n\n\n\n\n\npart_weight_physical(N::Integer, x_cgs::Real=3.085678e21)\n\nPhysical weighting function in units of [cm].      To be used with healpix_map.\n\n\n\n\n\n","category":"function"},{"location":"mapping/#SPHtoGrid.part_weight_emission","page":"Mapping SPH Data","title":"SPHtoGrid.part_weight_emission","text":"part_weight_emission(rho::Array{<:Real}, T_K::Array{<:Real})\n\nEmission weighted mapping. Takes density in internal untis and temperature in K and computes weights.\n\n\n\n\n\n","category":"function"},{"location":"mapping/#SPHtoGrid.part_weight_spectroscopic","page":"Mapping SPH Data","title":"SPHtoGrid.part_weight_spectroscopic","text":"part_weight_spectroscopic(rho::Array{<:Real}, T_K::Array{<:Real})\n\nSpectroscopic weighted mapping from Mazotta+ 04. Takes density and temperature and computes weights.\n\n\n\n\n\n","category":"function"},{"location":"mapping/#SPHtoGrid.part_weight_XrayBand","page":"Mapping SPH Data","title":"SPHtoGrid.part_weight_XrayBand","text":"part_weight_XrayBand(T_K::Array{<:Real}, Emin::Real, Emax::Real)\n\nComputes Xray weighted emission of a defined energy band. Emin and Emax are energies in eV.\n\n\n\n\n\n","category":"function"},{"location":"mapping/#Units","page":"Mapping SPH Data","title":"Units","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"As you have to handle unit conversion yourself please note that internally the image contains two components:  image is the mapped pixel value and wimage is just the geometry weighting of the particle which will be applied if reduce_image=true in sphMapping.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"This means that the resulting images have the units:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"image = [Bin_Quant] * [Weights] * [pix^2]","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"wimage = [Weights] * [pix^2]","category":"page"},{"location":"mapping/#Helper-Function","page":"Mapping SPH Data","title":"Helper Function","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"If you're lazy like me and don't want to go through the entire process of image reduction and saving the fits file by hand you can use","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"map_it","category":"page"},{"location":"mapping/#SPHtoGrid.map_it","page":"Mapping SPH Data","title":"SPHtoGrid.map_it","text":"map_it(pos_in, hsml, mass, rho, bin_q, weights, RM=nothing;\n       param::mappingParameters,\n       kernel::AbstractSPHKernel=WendlandC6(2), \n       snap::Integer=0, \n       units::AbstractString=\"\", \n       image_prefix::String=\"dummy\",\n       reduce_image::Bool=true, \n       parallel=true,\n       calc_mean::Bool=true, show_progress::Bool=true,\n       sort_z::Bool=false,\n       stokes::Bool=false,\n       projection=\"xy\")\n\nSmall helper function to copy positions, map particles and save the fits file.\n\nArguments\n\npos_in: Matrix (3xNpart) with particle positions\nhsml: Array with particle hsml\nmass: Array with particle masses\nrho: Array with particle densities\nbin_q: Array with particle quantity to be mapped\nweights: Array with weights. Defaults to density-weighted\nparam: mappingParameters for this map\nkernel: AbstractSPHKernel to be used for mapping\nunits: Unit string will be saved to FITS file\nimage_prefix: Name of the file to save, withou .fits file-ending\nreduce_image: If weights need to be applied or not. Set to false for part_weight_physical\nparallel: Run on multiple processors.\ncalc_mean: Calculates the mean value along the line of sight. If set to false the particle only contributes if its bin_q is larger than 0.\nshow_progress: Show progress bar\nsort_z: Sort the particles according to their line-of-sight direction. Needed for polarisation mapping.\nstokes: Set to true of you are mapping Stokes parameters to account for Faraday rotation of the polarisation angle.\nprojection: Which plane the position should be rotated in. Can also be an Array of 3 Euler angles (in [°]) (not used yet!)\n\n\n\n\n\n","category":"function"},{"location":"mapping/#Comparison-to-Smac","page":"Mapping SPH Data","title":"Comparison to Smac","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"As a reference for the mapping we use Smac (Dolag et al. 2005). You can see the comparison with the relative error in the following images. Differences in the LOS integration stem from a relative shift of the SPHtoGrid image by one pixel. The bulk of the error in the density weighted map stems from a slightly different calculation of the temperature.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Line-of-sight integration Density weighted\n(Image: rho_allsky) (Image: T_allsky)","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager.","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add SPHtoGrid","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"Now you should be good to go!","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\", \n          \"install.md\", \n          \"mapping.md\",\n          \"healpix.md\",\n          \"effects.md\",\n          \"rotating.md\",\n          \"external.md\", \n          \"api.md\"]\nDepth = 3","category":"page"},{"location":"io/#IO","page":"Saving/Loading Images","title":"IO","text":"","category":"section"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"If you want to store the constructed images you can save them as FITS files. This way you can open them in any code/program you want to make plots later.","category":"page"},{"location":"io/#Saving","page":"Saving/Loading Images","title":"Saving","text":"","category":"section"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"To save an image and the relevant fields from the mappingParameters struct you can use the function write_fits_image:","category":"page"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"write_fits_image","category":"page"},{"location":"io/#SPHtoGrid.write_fits_image","page":"Saving/Loading Images","title":"SPHtoGrid.write_fits_image","text":"write_fits_image(filename::String, image::Array{<:Real}, \n                        par::mappingParameters; \n                        units::String=\"[i.u.]\",\n                        snap::Integer=0)\n\nWrites a mapped image to a FITS file and stored the essential mapping parameters in the header.\n\n\n\n\n\nwrite_fits_image(filename::String, image::Array{<:Real};\n                units::String = \"[i.u.]\",\n                snap::Integer = 0)\n\nWrites a mapped allsky image to a FITS file and stored units and snapshot number in the header.\n\n\n\n\n\n","category":"function"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"The keyword arguments units and snap are optional and are used to store a unit string and the snapshot number for the image, respectively.","category":"page"},{"location":"io/#Reading","page":"Saving/Loading Images","title":"Reading","text":"","category":"section"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"To read a mapped image from a FITS file you can use read_fits_image:","category":"page"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"read_fits_image","category":"page"},{"location":"io/#SPHtoGrid.read_fits_image","page":"Saving/Loading Images","title":"SPHtoGrid.read_fits_image","text":"read_fits_image(filename::String)\n\nRead a FITS file and return the image, mappingParameters and the snapshot number.\n\nReturns\n\nimage: A 2D array with the image pixels \npar:   mappingParameters used for the image \nsnap:  Number of the mapped snapshot\nunits: A unit string of the image\n\nExample\n\nimage, par, snapnr, unitstring = readfitsimage(filename)\n\n\n\n\n\n","category":"function"},{"location":"rotating/#Rotating-images","page":"Rotating Images","title":"Rotating images","text":"","category":"section"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"By default sphMapping only maps the xy-plane. To change the mapping you have two options, Project along axis and Define Euler Angle.","category":"page"},{"location":"rotating/#Project-along-axis","page":"Rotating Images","title":"Project along axis","text":"","category":"section"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"If you only want to change the axis along which you want to project the data you can use the wrapper function project_along_axis. ","category":"page"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"project_along_axis","category":"page"},{"location":"rotating/#SPHtoGrid.project_along_axis","page":"Rotating Images","title":"SPHtoGrid.project_along_axis","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"If you for example want to project along the x-axes, so in the yz-plane use","category":"page"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"axis = 1\npos_new = (pos_old, axis)","category":"page"},{"location":"rotating/#Define-Euler-Angle","page":"Rotating Images","title":"Define Euler Angle","text":"","category":"section"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"If projection along one of the principle axis is too crude for you, you can define individual angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively and use the function rotate_3D. This function uses Rotations.jl.","category":"page"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"rotate_3D","category":"page"},{"location":"rotating/#SPHtoGrid.rotate_3D","page":"Rotating Images","title":"SPHtoGrid.rotate_3D","text":"rotate_3D(x::Array{<:Real}, alpha::Real, beta::Real, gamma::Real)\n\nRotates and array of 3D positions around the euler angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively. α, β and γ need to be given in degrees.\n\n\n\n\n\n","category":"function"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"These angles have to be given in degrees. So to rotate a 3D quantity 45 degrees around the x-axis you can use:","category":"page"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"pos_new = rotate_3D(pos_old, 45.0, 0.0, 0.0)","category":"page"}]
}
