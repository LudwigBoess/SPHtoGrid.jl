var documenterSearchIndex = {"docs":
[{"location":"effects/#Effects","page":"Effect maps","title":"Effects","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"If you want to map more than the primitive output quantities to a grid you can use some helper functions to map special effects.","category":"page"},{"location":"effects/#D-surface-density","page":"Effect maps","title":"2D surface density","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"To get the projected 2D surface density from your data you can use","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"density_2D(rho::Real, pixelSideLength::Real, \n           Mass::Real=1.989e43, Length::Real=3.085678e21)","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"where rho is the density in internal units, pixelSideLength can be taken from the mappingParameters struct and Mass and Length define the mass and length unit of the simulation respectively. To use this function you need to map the quantity without weighting, so:","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"par     = mappingParameters(...)\nbin_q   = density_2D.(rho, par.pixelSideLength)\nweights = part_weight_one(length(bin_q))","category":"page"},{"location":"effects/#Units","page":"Effect maps","title":"Units","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"The units in this case are of course gcm^2.","category":"page"},{"location":"effects/#X-Ray-emission","page":"Effect maps","title":"X-Ray emission","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"To compute the contribution of each particle to the total (thermal) X-ray emission you can use","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"x_ray_emission( n_cm3::Real, T_eV::Real; \n                Emin::Real=5.e4, Emax::Real=1.e10, \n                xH::Real=0.76)","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"where n_cm3 is the particle density in 1cm^3, T_eV is the temperature in electron volts. The optional input arguments Emin and Emax give the minimum and maximum energy range of the observational instrument, while xH gives the hydrogen fraction of the simulation.","category":"page"},{"location":"effects/#Weights","page":"Effect maps","title":"Weights","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"The correct weight function in this case is","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"weights = part_weight_physical(length(bin_q), par)","category":"page"},{"location":"effects/#Units-2","page":"Effect maps","title":"Units","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"This returns a map in the units ergcm^2sHz.","category":"page"},{"location":"effects/#Sunyaev-Z'eldovich-Effect","page":"Effect maps","title":"Sunyaev-Z'eldovich Effect","text":"","category":"section"},{"location":"effects/#Thermal","page":"Effect maps","title":"Thermal","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"To compute the contribution of each particle to the thermal SZ-effect you can use","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"thermal_SZ( n_cm3::Real, T::Real, \n            z::Real=0.0, ν::Real=1.44e9; \n            DI_over_I::Bool=false )","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"where n_cm3 is the particle density in 1cm^3, T is the temperature in Kelvin, z is the redshift and ν is the observation frequency. DI_over_I outputs in units of dII if set to true and dT/T otherwise.","category":"page"},{"location":"effects/#Kinetic","page":"Effect maps","title":"Kinetic","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"To compute the contribution of each particle to the kinetic SZ-effect you can use","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"kinetic_SZ( n_cm3::Real, vel_y_cgs::Real, \n            ν::Real=1.e9, z::Real=0.0; \n            DI_over_I::Bool=false )","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"where n_cm3 is the particle density in 1cm^3, vel_y_cgs is the velocity in y-direction to the projection plane in cm/s, z is the redshift and ν is the observation frequency. DI_over_I outputs in units of dII if set to true and dT/T otherwise.","category":"page"},{"location":"effects/#Weights-2","page":"Effect maps","title":"Weights","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"Independent of what version of the SZ effect you want to map you need to use the physical weight function","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"weights = part_weight_physical(length(bin_q), par)","category":"page"},{"location":"effects/#Units-3","page":"Effect maps","title":"Units","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"This produces a unitless map.","category":"page"},{"location":"effects/#Synchrotron-Emission","page":"Effect maps","title":"Synchrotron Emission","text":"","category":"section"},{"location":"effects/#Analytic-Synchrotron-Emission","page":"Effect maps","title":"Analytic Synchrotron Emission","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"You can calculate the analytic synchrotron emission of a particle as described in Loungair 8.128 with","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"analytic_synchrotron_emission( rho_cgs::Array{<:Real}, B_cgs::Array{<:Real},\n                               T_K::Array{<:Real}, Mach::Array{<:Real};\n                               xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.4e9,\n                               integrate_pitch_angle::Bool=true )","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"where rho_cgs is the density in gcm^3, B_cgs is the magnetic field in Gauss, T_K is the temperature in Kelvin and Mach is the shock Mach number. The keyword argument xH gives the hydrogen fraction of the simulation, if the simulation was run without a chemical model. This has to be extended to work with a chemical model as well. dsa_model defines the Diffuse-Shock-Acceleration model which should be used. It takes the values 0...4. These refer to KR07_acc, KR13_acc, Ryu19_acc, CS14_acc and P16_acc respectively.","category":"page"},{"location":"effects/#Weights-3","page":"Effect maps","title":"Weights","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"The correct weight function is","category":"page"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"weights = part_weight_physical(length(bin_q), par)","category":"page"},{"location":"effects/#Units-4","page":"Effect maps","title":"Units","text":"","category":"section"},{"location":"effects/","page":"Effect maps","title":"Effect maps","text":"This gives a map in the units erg*scm^2.","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = SPHtoGrid\nDocTestSetup = quote\n    using SPHtoGrid\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHtoGrid.analytic_synchrotron_emission-Tuple{Array{var\"#s108\",N} where N where var\"#s108\"<:Real,Array{var\"#s103\",N} where N where var\"#s103\"<:Real,Array{var\"#s102\",N} where N where var\"#s102\"<:Real,Array{var\"#s101\",N} where N where var\"#s101\"<:Real}","page":"API reference","title":"SPHtoGrid.analytic_synchrotron_emission","text":"analytic_synchrotron_emission( rho_cgs::Array{<:Real}, B_cgs::Array{<:Real},\n                               T_K::Array{<:Real}, Mach::Array{<:Real};\n                               xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.4e9,\n                               integrate_pitch_angle::Bool=true )\n\nComputes the analytic synchrotron emission with the simplified approach described in Longair Eq. 8.128.\n\nArguments\n\nrho_cgs::Array{<:Real}: Density in gcm^3.\nB_cgs::Array{<:Real}:   Magnetic field in Gauss.\nT_K::Array{<:Real}:     Temperature in Kelvin.\nMach::Array{<:Real}:    Mach number.\n\nKeyword Arguments\n\nxH::Float64 = 0.76:               Hydrogen fraction of the simulation, if run without chemical model.\ndsa_model::Integer=1:             Diffuse-Shock-Acceleration model. Takes values 0...4, see next section.\nν0::Real=1.4e9:                   Observation frequency in Hz.\nintegrate_pitch_angle::Bool=true: Integrates over the pitch angle as in Longair Eq. 8.87.\n\nDSA models\n\n0: KR07_acc. Efficiency model from Kang, Ryu, Cen, Ostriker 2007, http://arxiv.org/abs/0704.1521v1.\n1: KR13_acc. Efficiency model from Kang&Ryu 2013, doi:10.1088/0004-637X/764/1/95 .\n2: Ryu19_acc. Efficiency model from Ryu et al. 2019, https://arxiv.org/abs/1905.04476 .\n3: CS14_acc. Efficiency model from Caprioli&Spitkovsky 2015, doi: 10.1088/0004-637x/783/2/91 .\n4: P16_acc. Constant efficiency as in Pfrommer+ 2016, doi: 10.1093/mnras/stw2941 .\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.density_2D","page":"API reference","title":"SPHtoGrid.density_2D","text":"density_2D( rho::Real, pixelSideLength::Real, \n            Mass::Real=1.989e43, Length::Real=3.085678e21)\n\nComputes the 2D density.\n\nReturns\n\n2D surface density in untis of [g/cm^2].\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.filter_particles_in_image-Tuple{Array{var\"#s54\",N} where N where var\"#s54\"<:Real,Array{var\"#s45\",N} where N where var\"#s45\"<:Real,mappingParameters}","page":"API reference","title":"SPHtoGrid.filter_particles_in_image","text":"filter_particles_in_image(x, hsml, param::mappingParameters)\n\nChecks if a particle is contained in the image and returns an array of Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_map_grid_2D-Tuple{mappingParameters}","page":"API reference","title":"SPHtoGrid.get_map_grid_2D","text":"get_map_grid_2D(par::mappingParameters)\n\nReconstruct the 2D grid used for mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_map_grid_3D-Tuple{mappingParameters}","page":"API reference","title":"SPHtoGrid.get_map_grid_3D","text":"get_map_grid_3D(par::mappingParameters)\n\nReconstruct the 3D grid used for mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.kinetic_SZ","page":"API reference","title":"SPHtoGrid.kinetic_SZ","text":"kinetic_SZ(n_cm3::Real, vel_y_cgs::Real, \n                ν::Real=1.e9, z::Real=0.0; \n                DI_over_I::Bool=false)\n\nComputes the kinetic Sunyaev-Zel'dovich effect from electron density n_cm3 and velocity in y-direction to the projection plane in cgs units vel_y_cgs. If DI_over_I is set to true you also need to provide an observation frequency ν and redshift z.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.part_weight_XrayBand","page":"API reference","title":"SPHtoGrid.part_weight_XrayBand","text":"part_weight_XrayBand(T::Array{<:Real}, Emin::Real, Emax::Real)\n\nComputes Xray weighted emission of a defined energy band. Emin and Emax are energies in eV.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.part_weight_emission-Tuple{Array{var\"#s427\",N} where N where var\"#s427\"<:Real,Array{var\"#s426\",N} where N where var\"#s426\"<:Real}","page":"API reference","title":"SPHtoGrid.part_weight_emission","text":"part_weight_emission(rho::Array{<:Real}, T::Array{<:Real})\n\nEmission weighted mapping. Takes density and temperature and computes weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.part_weight_one-Tuple{Integer}","page":"API reference","title":"SPHtoGrid.part_weight_one","text":"part_weight_one(N::Integer)\n\nEquivalent to no weighting. Returns an Array of ones.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.part_weight_physical-Tuple{Integer,mappingParameters}","page":"API reference","title":"SPHtoGrid.part_weight_physical","text":"part_weight_physical(N::Integer, par::mappingParameters)\n\nPhysical weighting function.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.project_along_axis","page":"API reference","title":"SPHtoGrid.project_along_axis","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.project_along_axis!","page":"API reference","title":"SPHtoGrid.project_along_axis!","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.project_along_axis!-2","page":"API reference","title":"SPHtoGrid.project_along_axis!","text":"project_along_axis!(x::Array{<:Real}, projection_axis::Integer=3)\n\nProjects and array of 3D along one of the principle axes. projection_axis ∈ {1, 2, 3} => x, y, z axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.read_fits_image-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_fits_image","text":"read_fits_image(filename::String)\n\nRead a FITS file and return the image, mappingParameters and the snapshot number.\n\nReturns\n\nimage: A 2D array with the image pixels \npar:   mappingParameters used for the image \nsnap:  Number of the mapped snapshot\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_smac1_binary_image-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_smac1_binary_image","text":"read_smac1_binary_image(filename::String)\n\nReads a binary image file from Smac and returns a Matrix with the pixel values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.read_smac1_binary_info-Tuple{String}","page":"API reference","title":"SPHtoGrid.read_smac1_binary_info","text":"read_smac1_binary_info(filename::String)\n\nReturns the image info in a Smac1ImageInfo struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_3D!-Tuple{Array{var\"#s102\",N} where N where var\"#s102\"<:Real,Real,Real,Real}","page":"API reference","title":"SPHtoGrid.rotate_3D!","text":"rotate_3D!(x::Array{<:Real}, alpha::Real, beta::Real, gamma::Real)\n\nRotates and array of 3D positions around the euler angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively. α, β and γ need to be given in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_3D-Tuple{Array{var\"#s102\",N} where N where var\"#s102\"<:Real,Real,Real,Real}","page":"API reference","title":"SPHtoGrid.rotate_3D","text":"rotate_3D(x::Array{<:Real}, alpha::Real, beta::Real, gamma::Real)\n\nRotates and array of 3D positions around the euler angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively. α, β and γ need to be given in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.sphMapping","page":"API reference","title":"SPHtoGrid.sphMapping","text":"function sphMapping(Pos::Array{<:Real}, HSML::Array{<:Real}, \n                    M::Array{<:Real}, ρ::Array{<:Real}, \n                    Bin_Quant::Array{<:Real},\n                    Weights::Array{<:Real}=ρ;\n                    param::mappingParameters,\n                    kernel::SPHKernel [,\n                    show_progress::Bool=true,\n                    parallel::Bool=false,\n                    filter_particles::Bool=true,\n                    dimensions::Int=2])\n\nMaps the data in Bin_Quant to a grid. Parameters of mapping are supplied in param and the kernel to be used in kernel.\n\nArguments\n\nPos: Array with particle positions.\nHSML: Array with particle hsml.\nM: Array with particle masses.\nρ: Array with particle densities.\nBin_Quant: Array with particle quantity to be mapped.\nWeights: Array with weights. Defaults to density-weighted.\nkernel::SPHKernel: Kernel object to be used.\nshow_progress::Bool=true: Show progress bar.\nparallel::Bool=true: Run on multiple processors.\nfilter_particles::Bool=true: Find the particles that are actually contained in the image.\ndimensions::Int=2: Number of mapping dimensions (2 = to grid, 3 = to cube).\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.sphMapping-Tuple{Array{var\"#s378\",N} where N where var\"#s378\"<:Real,Array{var\"#s377\",N} where N where var\"#s377\"<:Real}","page":"API reference","title":"SPHtoGrid.sphMapping","text":"sphMapping( Pos::Array{<:Real}, Bin_Quant::Array{<:Real};\n            param::mappingParameters,\n            show_progress::Bool=true,\n            dimensions::Int=2)\n\nMaps the data in Bin_Quant to a grid using triangualar shaped cloud (TSC) interpolation.\n\nArguments\n\nPos: Array with particle positions.\nBin_Quant: Array with particle quantity to be mapped.\nshow_progress::Bool=true: Show progress bar.\nfilter_particles::Bool=true: If particles should be filtered before mapping.\ndimensions::Int=2: Number of mapping dimensions (2 = to grid, 3 = to cube).\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.thermal_SZ","page":"API reference","title":"SPHtoGrid.thermal_SZ","text":"thermal_SZ(n_cm3::Real, T::Real, z::Real=0.0, ν::Real=1.44e9)\n\nComputes the thermal Sunyaev-Zel'dovich effect for electron density n_cm3 and temperature T in Kelvin at redshift z and observer frequency ν.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.write_fits_image-Tuple{String,Array{var\"#s425\",N} where N where var\"#s425\"<:Real,mappingParameters}","page":"API reference","title":"SPHtoGrid.write_fits_image","text":"write_fits_image(filename::String, image::Array{<:Real}, \n                        par::mappingParameters; \n                        units::String=\"[i.u.]\",\n                        snap::Integer=0)\n\nWrites a mapped image to a FITS file and stored the essential mapping parameters in the header.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.write_smac1_par","page":"API reference","title":"SPHtoGrid.write_smac1_par","text":"write_smac1_par([...])\n\nWrites a Smac parameter file. Not all relevant parameters implemented yet!\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.write_smac2_par","page":"API reference","title":"SPHtoGrid.write_smac2_par","text":"write_smac2_par([...])\n\nWrites a P-Smac2 parameter file. Not all relevant parameters implemented yet!\n\n\n\n\n\n","category":"function"},{"location":"api/#SPHtoGrid.x_ray_emission-Tuple{Real,Real}","page":"API reference","title":"SPHtoGrid.x_ray_emission","text":"x_ray_emission(n_cm3::Real, T_K::Real; \n               Emin::Real=5.e4, Emax::Real=1.e10, \n               xH::Real=0.76)\n\nX-Ray emission of a particle with number density n_cm3 in 1cm^3 and temperature T in K. Emin and Emax give the minimum and maximum energy of the oberservation. xH gives the hydrogen fraction used in the simulation.\n\nReturns\n\nX-Ray surface brightness contribution in units of [erg/cm^2/s/Hz].\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHtoGrid.mappingParameters","page":"API reference","title":"SPHtoGrid.mappingParameters","text":"struct mappingParameters\n    x_lim::Vector{Float64}\n    y_lim::Vector{Float64}\n    z_lim::Vector{Float64}\n    center::Vector{Float64}\n    pixelSideLength::Float64\n    pixelArea::Float64\n    Npixels::Vector{Int64}\n    x_size::Float64\n    y_size::Float64\n    z_size::Float64\nend\n\nConstructor:\n\nmappingParameters(;x_lim::Vector{Float64}   = [-1.0, -1.0],\n                   y_lim::Vector{Float64}   = [-1.0, -1.0],\n                   z_lim::Vector{Float64}   = [-1.0, -1.0],\n                   center::Vector{Float64}  = [-1.0, -1.0, -1.0],\n                   x_size::Float64          =  -1.0,\n                   y_size::Float64          =  -1.0,\n                   z_size::Float64          =  -1.0,\n                   pixelSideLength::Float64 =  -1.0,\n                   Npixels::Int64           =   0)\n\nParameter object for sph to grid mapping. Define either *_lim, or center and *_size.  Resolution is defined by pixelSideLength or Npixels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHtoGrid.CS14_acc-Tuple{Real}","page":"API reference","title":"SPHtoGrid.CS14_acc","text":"CS14_acc(M::Real)\n\nEfficiency from Caprioli&Spitkovsky 2015, doi: 10.1088/0004-637x/783/2/91 Same simplified approach as Vazza+12 -> is roughly half the efficiency of Kang&Ryu 2013.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.EpsNtherm-Tuple{Real,Real}","page":"API reference","title":"SPHtoGrid.EpsNtherm","text":"EpsNtherm(rho_cgs::Real, T_K::Real)\n\nThermal energy density in cgs.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.KR07_acc-Tuple{Float64}","page":"API reference","title":"SPHtoGrid.KR07_acc","text":"KR07_acc(M::Float64)\n\nEfficiency model from Kang, Ryu, Cen, Ostriker 2007, http://arxiv.org/abs/0704.1521v1\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.KR13_acc-Tuple{Real}","page":"API reference","title":"SPHtoGrid.KR13_acc","text":"KR13_acc(M::Real)\n\nEfficiency model from Kang&Ryu 2013, doi:10.1088/0004-637X/764/1/95\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.P16_acc-Tuple{Real}","page":"API reference","title":"SPHtoGrid.P16_acc","text":"P16_acc(M::Real)\n\nConstant efficiency as in Pfrommer+ 2016, doi: 10.1093/mnras/stw2941 \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.Ryu19_acc-Tuple{Real}","page":"API reference","title":"SPHtoGrid.Ryu19_acc","text":"Ryu19_acc(M::Real)\n\nEfficiency model from Ryu et al. 2019, https://arxiv.org/abs/1905.04476 Values for 2.25 < M <= 5.0 extrapolated to entire range\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.Tcmb-Tuple{Real}","page":"API reference","title":"SPHtoGrid.Tcmb","text":"Tcmb(z::Real)\n\nComputes the temperature of the CMB at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_index_2D-Tuple{Integer,Integer,Integer}","page":"API reference","title":"SPHtoGrid.calculate_index_2D","text":"function calculate_index_2D(i::Integer, j::Integer, x_pixels::Integer)\n\nCalculates the index of a flattened 2D image array.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_index_3D-NTuple{5,Integer}","page":"API reference","title":"SPHtoGrid.calculate_index_3D","text":"function calculate_index_3D(i::Integer, j::Integer, x_pixels::Integer)\n\nCalculates the index of a flattened 3D image array.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights_2D-Tuple{Array{var\"#s44\",1} where var\"#s44\"<:Real,Integer,Integer,Integer,Integer,Real,Real,Real,Real,SPHKernels.SPHKernel,Integer}","page":"API reference","title":"SPHtoGrid.calculate_weights_2D","text":"function calculate_weights_2D(  wk::Array{<:Real,1}, \n                                iMin::Integer, iMax::Integer, \n                                jMin::Integer, jMax::Integer,\n                                x::Real, y::Real, hsml::Real, hsml_inv::Real,\n                                kernel::SPHKernel,\n                                x_pixels::Integer )\n\nCalculates the kernel- and geometric weights of the pixels a particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.calculate_weights_3D-Tuple{Array{var\"#s54\",1} where var\"#s54\"<:Real,Integer,Integer,Integer,Integer,Integer,Integer,Real,Real,Real,Real,Real,SPHKernels.SPHKernel,Integer,Integer}","page":"API reference","title":"SPHtoGrid.calculate_weights_3D","text":"function calculate_weights_3D(  wk::Array{<:Real,1}, \n                                iMin::Integer, iMax::Integer, \n                                jMin::Integer, jMax::Integer,\n                                kMin::Integer, kMax::Integer,\n                                x::Real, y::Real, z::Real, \n                                hsml::Real, hsml_inv::Real,\n                                kernel::SPHKernel,\n                                x_pixels::Integer, y_pixels::Integer )\n\nCalculates the kernel- and geometric weights of the pixels a particle contributes to.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.check_center_and_move_particles-Tuple{Array{var\"#s55\",N} where N where var\"#s55\"<:Real,mappingParameters}","page":"API reference","title":"SPHtoGrid.check_center_and_move_particles","text":"check_center_and_move_particles(x, par::mappingParameters)\n\nMapping only works if all coordinates are positive. This function shifts the particles accordingly.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.check_in_image-NTuple{7,Real}","page":"API reference","title":"SPHtoGrid.check_in_image","text":"check_in_image(x::Real, y::Real, z::Real, hsml::Real,\n                            halfXsize::Real, halfYsize::Real, halfZsize::Real)\n\nChecks if a particle is in the image frame.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.comptonY-Tuple{Real,Real,Real}","page":"API reference","title":"SPHtoGrid.comptonY","text":"comptonY(n_cm3::Real, T_K::Real, z::Real)\n\nComputes the Compton-Y parameter from electron density n_cm3 and temperature T in Kelvin at redshift z.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.cre_spec_norm_particle-Tuple{Real,Function}","page":"API reference","title":"SPHtoGrid.cre_spec_norm_particle","text":"cre_spec_norm_particle(M::Real, eff_function::Function)\n\nComputes the CR electron norm of the particles.  This depends on the Mach number M and the acceleration efficiency given by eff_function.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.domain_decomposition-Tuple{Integer,Integer}","page":"API reference","title":"SPHtoGrid.domain_decomposition","text":"domain_decomposition(N::Int64, N_workers::Int64)\n\nCalculate relevant array slices for each worker. Could be done better!\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.dsa_spectral_index-Tuple{Real}","page":"API reference","title":"SPHtoGrid.dsa_spectral_index","text":"dsa_spectral_index(M::Real)\n\nSpectral index given by standard Diffuse-Shock-Acceleration (DSA).\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.euler_matrix-Tuple{Real,Real,Real}","page":"API reference","title":"SPHtoGrid.euler_matrix","text":"euler_matrix(α::Real, β::Real, γ::Real)\n\nReturns the rotation matrix A based on rotation along the euler angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.find_position_periodic-Tuple{Array{var\"#s57\",N} where N where var\"#s57\"<:Real,Integer,Real}","page":"API reference","title":"SPHtoGrid.find_position_periodic","text":"find_position_periodic( pos::Array{<:Real}, k::Integer, boxsize::Real)\n\nPerforms a periodic mapping of the particle position.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_d_hsml_2D-Tuple{Real,Real,Real}","page":"API reference","title":"SPHtoGrid.get_d_hsml_2D","text":"get_d_hsml_2D( dx::Real, dy::Real,\n               hsml_inv::Real )\n\nComputes the distance in 2D to the pixel center in units of the kernel support.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_d_hsml_3D-NTuple{4,Real}","page":"API reference","title":"SPHtoGrid.get_d_hsml_3D","text":"get_d_hsml_3D( dx::Real, dy::Real, dz::Real,\n               hsml_inv::Real )\n\nComputes the distance in 3D to the pixel center in units of the kernel support.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_dxyz-Tuple{Real,Real,Integer}","page":"API reference","title":"SPHtoGrid.get_dxyz","text":"function get_dxyz(x::Real, hsml::Real, i::Integer)\n\nCalculates the extent of the current particle size in units of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_ijk_min_max-Tuple{Real,Real,Integer}","page":"API reference","title":"SPHtoGrid.get_ijk_min_max","text":"function get_ijk_min_max( x::Real, hsml::Real,\n                          x_pixels::Integer)\n\nCalculates the minimum and maximum pixel to which a particle contributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.get_xyz-Tuple{Array{var\"#s56\",1} where var\"#s56\"<:Real,Real,Integer,Real,Integer,Integer,Integer,Real,Bool,Real,Real,Real,Integer}","page":"API reference","title":"SPHtoGrid.get_xyz","text":"function get_xyz( pos::Vector{<:Real}, hsml::Real, k::Integer,\n                  len2pix::Real, x_pixels::Integer, y_pixels::Integer, z_pixels::Integer,\n                  boxsize::Real, periodic::Bool,\n                  halfXsize::Real, halfYsize::Real, halfZsize::Real,\n                  Ndim::Integer)\n\nCalculates x, y, z position in units of pixels and performs periodic mapping, if required.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.kSzPrefac-Tuple{Real,Real,Bool}","page":"API reference","title":"SPHtoGrid.kSzPrefac","text":"kSzPrefac(ν::Real, z::Real, DI_over_I::Bool)\n\nPrefactor for the kinetic Sunyaev-Zel'dovich effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.kr_fitting_function-NTuple{6,Real}","page":"API reference","title":"SPHtoGrid.kr_fitting_function","text":"kr_fitting_function(x::Real, \n                         a0::Real, a1::Real, a2::Real, a3::Real, a4::Real)\n\nHelper function to use the fitting function from KR07.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.part_weight_spectroscopic-Tuple{Array{var\"#s427\",N} where N where var\"#s427\"<:Real,Array{var\"#s426\",N} where N where var\"#s426\"<:Real}","page":"API reference","title":"SPHtoGrid.part_weight_spectroscopic","text":"part_weight_spectroscopic(rho::Array{<:Real}, T::Array{<:Real})\n\nSpectroscopic weighted mapping from Mazotta+ 04. Takes density and temperature and computes weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.reduce_image_2D-Tuple{Array{var\"#s55\",N} where N where var\"#s55\"<:Real,Int64,Int64}","page":"API reference","title":"SPHtoGrid.reduce_image_2D","text":"function reduce_image_2D( image::Array{<:Real},\n                          x_pixels::Int64, y_pixels::Int64)\n\nUnflattens an image array to a 2D array of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.reduce_image_3D-Tuple{Array{var\"#s54\",N} where N where var\"#s54\"<:Real,Int64,Int64,Int64}","page":"API reference","title":"SPHtoGrid.reduce_image_3D","text":"function reduce_image_3D( image::Array{<:Real}, w_image::Array{<:Real},\n                                        x_pixels::Int64, y_pixels::Int64, z_pixels::Int64)\n\nUnflattens an image array to a 3D array of pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_3D_quantity-Tuple{Array{var\"#s108\",N} where N where var\"#s108\"<:Real,Real,Real,Real}","page":"API reference","title":"SPHtoGrid.rotate_3D_quantity","text":"rotate_3D_quantity(x, α, β, γ)\n\nRotates a 3D vector along the x-axis with angle α, y-axis with angle β and z-axis with angle γ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_xz_plane!-Tuple{Array{var\"#s101\",N} where N where var\"#s101\"<:Real,Array{var\"#s99\",N} where N where var\"#s99\"<:Real}","page":"API reference","title":"SPHtoGrid.rotate_to_xz_plane!","text":"rotate_to_xz_plane!(x::Array{<:Real})\n\nRotates an array of 3D positions into the xz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_xz_plane!-Tuple{Array{var\"#s102\",N} where N where var\"#s102\"<:Real}","page":"API reference","title":"SPHtoGrid.rotate_to_xz_plane!","text":"rotate_to_xz_plane!(x::Array{<:Real})\n\nRotates an array of 3D positions into the xz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_yz_plane!-Tuple{Array{var\"#s101\",N} where N where var\"#s101\"<:Real,Array{var\"#s99\",N} where N where var\"#s99\"<:Real}","page":"API reference","title":"SPHtoGrid.rotate_to_yz_plane!","text":"rotate_to_yz_plane(x::Array{<:Real}, x_in::Array{<:Real})\n\nRotates an array of 3D positions into the yz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.rotate_to_yz_plane!-Tuple{Array{var\"#s102\",N} where N where var\"#s102\"<:Real}","page":"API reference","title":"SPHtoGrid.rotate_to_yz_plane!","text":"rotate_to_yz_plane(x::Array{<:Real})\n\nRotates an array of 3D positions into the yz-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.sphMapping_2D-Tuple{Array{var\"#s94\",N} where N where var\"#s94\"<:Real,Array{var\"#s95\",N} where N where var\"#s95\"<:Real,Array{var\"#s96\",N} where N where var\"#s96\"<:Real,Array{var\"#s97\",N} where N where var\"#s97\"<:Real,Array{var\"#s98\",N} where N where var\"#s98\"<:Real,Array{var\"#s99\",N} where N where var\"#s99\"<:Real}","page":"API reference","title":"SPHtoGrid.sphMapping_2D","text":"sphMapping2D( Pos::Array{<:Real}, HSML::Array{<:Real},                    M::Array{<:Real}, Rho::Array{<:Real},                    BinQ::Array{<:Real}, Weights::Array{<:Real}=ones(length(Rho));                   param::mappingParameters, kernel::SPHKernel,                   show_progress::Bool=false )\n\nUnderlying function to map SPH data to a 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.sphMapping_3D-Tuple{Array{var\"#s28\",N} where N where var\"#s28\"<:Real,Array{var\"#s27\",N} where N where var\"#s27\"<:Real,Array{var\"#s26\",N} where N where var\"#s26\"<:Real,Array{var\"#s25\",N} where N where var\"#s25\"<:Real,Array{var\"#s24\",N} where N where var\"#s24\"<:Real,Array{var\"#s23\",N} where N where var\"#s23\"<:Real}","page":"API reference","title":"SPHtoGrid.sphMapping_3D","text":"sphMapping2D( Pos::Array{<:Real}, HSML::Array{<:Real},                    M::Array{<:Real}, Rho::Array{<:Real},                    BinQ::Array{<:Real}, Weights::Array{<:Real}=ones(length(Rho));                   param::mappingParameters, kernel::SPHKernel,                   show_progress::Bool=false )\n\nUnderlying function to map SPH data to a 3D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.tSzPrefac-Tuple{Real,Real,Bool}","page":"API reference","title":"SPHtoGrid.tSzPrefac","text":"tSzPrefac(ν::Real, z::Real)\n\nComputes the prefactor for the thermal Sunyaev-Zel'dovich effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHtoGrid.update_image-NTuple{5,Real}","page":"API reference","title":"SPHtoGrid.update_image","text":"function update_image( image::Real, w_image::Real, \n                       wk::Real, bin_q::Real, \n                       geometry_norm::Real )\n\nApplies the different contributions to the image and the weight image.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHtoGrid]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHtoGrid.Smac1ImageInfo","page":"API reference","title":"SPHtoGrid.Smac1ImageInfo","text":"struct Smac1ImageInfo\n\nStores the information in a Smac binary image header.\n\n\n\n\n\n","category":"type"},{"location":"external/#External-Programs","page":"External Programs","title":"External Programs","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"SPHtoGrid.jl provides helper function for two external sph mapping Codes: Smac and P-Smac2.","category":"page"},{"location":"external/#P-Smac2","page":"External Programs","title":"P-Smac2","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"P-Smac2 by Julius Donnert is an advanced mapping code for a multitude of different quantities. To run a mapping and plotting loop from a Julia script you need to update the parameter files on the fly. The function write_smac2_par provides this functionality.","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"write_smac2_par(x, y, z,\n                euler_angle_0, euler_angle_1, euler_angle_2,\n                xy_size, z_depth, xy_pix::Int64,\n                input_file, output_file, path,\n                effect_module::Int64=0, effect_flag::Int64=0)","category":"page"},{"location":"external/#Smac","page":"External Programs","title":"Smac","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"Smac is a SPH mapping Code by Klaus Dolag and others. The implementation is described in Dolag et al. 2005.","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"Smac isn't public unfortunately. So these functions are mainly for my personal use. If you do have access to Smac, here's a reference to what you can do.","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"SPHtoGrid.jl provides some functions to read the binary output of Smac, as I personally prefer that over the FITS output. To get the binary format you need to set FILE_FORMAT = 1 in the parameter file.","category":"page"},{"location":"external/#Reading-image-information","page":"External Programs","title":"Reading image information","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"If you set FILE_HEADER = 1 in the Smac parameter file you can read the information of the image header into a Smac1ImageInfo object like so:","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"info = read_smac1_binary_info(filename)","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"The Smac1ImageInfo object contains the following information","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"struct Smac1ImageInfo\n\n    snap::Int32                 # number of input snapshot\n    z::Float32                  # redshift of snapshot\n    m_vir::Float32              # virial mass of halo\n    r_vir::Float32              # virial radius of halo\n    xcm::Float32                # x coordinate of image center\n    ycm::Float32                # y coordinate of image center\n    zcm::Float32                # z coordinate of image center\n    z_slice_kpc::Float32        # depth of the image in kpc\n    boxsize_kpc::Float32        # xy-size of the image in kpc\n    boxsize_pix::Float32        # xy-size of the image in pixels\n    pixsize_kpc::Float32        # size of one pixel in kpc\n    xlim::Array{Float64,1}      # x limits of image\n    ylim::Array{Float64,1}      # y limits of image\n    zlim::Array{Float64,1}      # z limits of image\n    units::String               # unitstring of image\n\nend\n","category":"page"},{"location":"external/#Reading-the-image","page":"External Programs","title":"Reading the image","text":"","category":"section"},{"location":"external/","page":"External Programs","title":"External Programs","text":"The image itself can be read with","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"image = read_smac1_binary_image(filename)","category":"page"},{"location":"external/","page":"External Programs","title":"External Programs","text":"This will return an Array{Float32,2} with the pixel values. You can pass this to any imshow function of your favorite plotting package.","category":"page"},{"location":"mapping/#Mapping-SPH-Data","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"CurrentModule = SPHtoGrid\nDocTestSetup = quote\n    using SPHtoGrid\nend","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"You can map SPH data to a grid using the function sphMapping, which comes in two flavors: CIC and TSC.","category":"page"},{"location":"mapping/#Define-parameters-for-mapping","page":"Mapping SPH Data","title":"Define parameters for mapping","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"To map the data you need to define the mapping parameters via the mappingParameters object. One way to set this up is by defining the limits of the map as","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"par = mappingParameters(xlim=[xmin, xmax],\n                        ylim=[ymin, ymax],\n                        zlim=[zmin, zmax],\n                        Npixels=200)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"or give a center position and the size in each direction","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"par = mappingParameters(center=[x0, y0, z0], \n                        x_size=x_size, \n                        y_size=y_size,\n                        z_size=z_size,\n                        Npixels=200)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Instead of Npixels you can also give the keyword argument pixelSideLength if you prefer to define your image that way.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"If you are mapping a periodic box you also can give the keyword boxsize to enable periodic mapping.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"par = mappingParameters(center=[x0, y0, z0], \n                        x_size=x_size, \n                        y_size=y_size,\n                        z_size=z_size,\n                        boxsize=boxsize,\n                        Npixels=200)","category":"page"},{"location":"mapping/#CIC","page":"Mapping SPH Data","title":"CIC","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"For \"Cloud in a Cell\" (CIC) interpolation use the function sphMapping with these input values:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"function sphMapping(Pos::Array{<:Real}, HSML::Array{<:Real}, \n                    M::Array{<:Real}, ρ::Array{<:Real}, \n                    Bin_Quant::Array{<:Real},\n                    Weights::Array{<:Real}=ρ;\n                    param::mappingParameters,\n                    kernel::SPHKernel [,\n                    show_progress::Bool=true,\n                    parallel::Bool=false,\n                    filter_particles::Bool=true,\n                    dimensions::Int=2])\n\n\n    [...]\n\nend","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"where Pos is the 3D positional data, HSML is the kernel support of each particle, M are the particle masses, ρ is the density of the particle, Bin_Quant is the qantity you want to bin and Weights is an array of weights. These weights can be calculated using one of the supplied Weight functions. They default to density weighted.","category":"page"},{"location":"mapping/#Select-Kernel","page":"Mapping SPH Data","title":"Select Kernel","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"You also need to choose the kernel you used in the simulation. For this you need to install the package SPHKernels.jl. You can currently use these kernels:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"k = Cubic()\nk = Quintic()\nk = WendlandC4()\nk = WendlandC6()","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Please see the SPHKernels docs for more details.","category":"page"},{"location":"mapping/#Mapping","page":"Mapping SPH Data","title":"Mapping","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"With the setup done you can now map (e.g.) density of your data using the function above as:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"image = sphMapping(x, hsml, m, rho, rho, param=par, kernel=k)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Replacing the second rho with any other quantity would map that quantity of course. Please note: This function doesn't do any unit conversion for you, so you need to convert to the desired units beforehand. You can do this e.g. with GadgetUnits.jl.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Image now contains a 2D array with the binned data and can easily be plotted with imshow() from any plotting package of your choosing.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"The keyword parallel = true causes the run to use multiple processors. For this you need to start julia with julia -p <N> where <N> is the number of processors in your machine, or define","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"using Distributed\naddprocs(8)\n\n# now you can load SPHtoGrid\nusing SPHtoGrid","category":"page"},{"location":"mapping/#Conserved-quantities","page":"Mapping SPH Data","title":"Conserved quantities","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"With the latest release the particles are mapped to a grid while also conserving the particle volume, following the algorithm described in Dolag et. al. 2006.","category":"page"},{"location":"mapping/#Weight-functions","page":"Mapping SPH Data","title":"Weight functions","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"With the mapping you may decide to use a specific weighting function. For this you can pass the optional variable Weights in sphMapping.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"You can either use your own weight functions or use one of the built-in ones:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"part_weight_one just returns an Array of ones.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"part_weight_physical converts from pixel- to physical units.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"part_weight_emission weights the contribution due to density and temperature of the particle.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"part_weight_spectroscopic gives spectroscopic weighting, see Mazotta+ 04.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"part_weight_XrayBand weights the particle due to its Xray emission in the defined energy band.","category":"page"},{"location":"mapping/#TSC","page":"Mapping SPH Data","title":"TSC","text":"","category":"section"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"A very simplistic approach to mapping SPH data is by using \"Triangular Shaped Cloud\" (TSC) interpolation. This has the advantage of only needing positional data to bin a quantity, so it works for mapping e.g. initial conditions that don't have values for HSML yet. To use this method call the sphMapping function with a reduced number of arguments:","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"sphMapping( Pos::Array{<:Real}, Bin_Quant::Array{<:Real};\n            param::mappingParameters,\n            show_progress::Bool=true,\n            dimensions::Int=2)","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"Mapping then works the same as in the CIC case.","category":"page"},{"location":"mapping/","page":"Mapping SPH Data","title":"Mapping SPH Data","text":"This only runs on a single core and will likely stay that way, as it is a \"quick-and-dirty\" method anyway.","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager. Until I decide if should register the TSC interpolation package you need to install if by hand first (I don't know why).","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add https://github.com/LudwigBoess/TriangularShapedCloudInterpolation.jl.git\npkg> add https://github.com/LudwigBoess/SPHtoGrid.jl","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"If you want to get the latest version use","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add https://github.com/LudwigBoess/SPHtoGrid.jl#development","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"Now you should be good to go!","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\", \n          \"install.md\", \n          \"mapping.md\",\n          \"weights.md\",\n          \"rotating.md\",\n          \"external.md\", \n          \"api.md\"]\nDepth = 3","category":"page"},{"location":"io/#IO","page":"Saving/Loading Images","title":"IO","text":"","category":"section"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"If you want to store the constructed images you can save them as FITS files. This way you can open them in any code/program you want to make plots later.","category":"page"},{"location":"io/#Saving","page":"Saving/Loading Images","title":"Saving","text":"","category":"section"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"To save an image and the relevant fields from the mappingParameters struct you can use the function write_fits_image:","category":"page"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"write_fits_image( filename::String, image::Array{<:Real}, \n                  par::mappingParameters; \n                  units::String=\"[i.u.]\",\n                  snap::Integer=0)","category":"page"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"The keyword arguments units and snap are optional and are used to store a unit string and the snapshot number for the image, respectively.","category":"page"},{"location":"io/#Reading","page":"Saving/Loading Images","title":"Reading","text":"","category":"section"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"To read a mapped image from a FITS file you can use read_fits_image:","category":"page"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"image, par, snap_nr, unit_string = read_fits_image(filename::String)","category":"page"},{"location":"io/","page":"Saving/Loading Images","title":"Saving/Loading Images","text":"Where image is the image, par is a struct of type mappingParameters, snap_nr is the number of the snapshot which was mapped and unit_string contains a string of the image units.","category":"page"},{"location":"rotating/#Rotating-images","page":"Rotating Images","title":"Rotating images","text":"","category":"section"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"By default sphMapping only maps the xy-plane. To change the mapping you have two options, Project along axis and Define Euler Angle.","category":"page"},{"location":"rotating/#Project-along-axis","page":"Rotating Images","title":"Project along axis","text":"","category":"section"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"If you only want to change the axis along which you want to project the data you can use the wrapper function project_along_axis. If you for example want to project along the x-axes, so in the yz-plane use","category":"page"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"axis = 1\npos_new = (pos_old, axis)","category":"page"},{"location":"rotating/#Define-Euler-Angle","page":"Rotating Images","title":"Define Euler Angle","text":"","category":"section"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"If projection along one of the principle axis is too crude for you, you can define individual angles α, β and γ corresponding to rotations around the x, y, and z-axis respectively and use the function rotate_3D. These angles have to be given in degrees. So to rotate a 3D quantity 45 degrees around the x-axis you can use:","category":"page"},{"location":"rotating/","page":"Rotating Images","title":"Rotating Images","text":"pos_new = rotate_3D(pos_old, 45.0, 0.0, 0.0)","category":"page"}]
}
