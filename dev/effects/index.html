<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SPHtoGrid.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SPHtoGrid.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table of Contents</a></li><li><a class="tocitem" href="../install/">Install</a></li><li><a class="tocitem" href="../mapping/">Mapping SPH Data</a></li><li><a class="tocitem" href="../healpix/">HealPix maps</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Read-data-and-convert-units"><span>Read data and convert units</span></a></li><li><a class="tocitem" href="#D-surface-density"><span>2D surface density</span></a></li><li><a class="tocitem" href="#Magnetic-Field"><span>Magnetic Field</span></a></li><li><a class="tocitem" href="#X-Ray-emission"><span>X-Ray emission</span></a></li><li><a class="tocitem" href="#Sunyaev-Z&#39;eldovich-Effect"><span>Sunyaev-Z&#39;eldovich Effect</span></a></li><li><a class="tocitem" href="#Gamma-Ray-emission"><span>Gamma Ray emission</span></a></li><li><a class="tocitem" href="#Synchrotron-Emission"><span>Synchrotron Emission</span></a></li><li><a class="tocitem" href="#Stellar/DM-density"><span>Stellar/DM density</span></a></li><li class="toplevel"><a class="tocitem" href="#Image-Functions"><span>Image Functions</span></a></li><li><a class="tocitem" href="#General"><span>General</span></a></li><li><a class="tocitem" href="#Synchrotron-Specific"><span>Synchrotron Specific</span></a></li></ul></li><li><a class="tocitem" href="../rotating/">Rotating Images</a></li><li><a class="tocitem" href="../io/">Saving/Loading Images</a></li><li><a class="tocitem" href="../external/">External Programs</a></li><li><a class="tocitem" href="../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/master/docs/src/effects.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>You can find some examples here for common maps. These examples assume that you also have <code>GadgetIO.jl</code>, <code>GadgetUnits.jl</code> and <code>SPHKernels.jl</code> installed.</p><p>In all examples <code>snap_base</code> points to the snapshot you want to map and <code>map_path</code> points to the folder where you want to store the fits files.</p><h2 id="Read-data-and-convert-units"><a class="docs-heading-anchor" href="#Read-data-and-convert-units">Read data and convert units</a><a id="Read-data-and-convert-units-1"></a><a class="docs-heading-anchor-permalink" href="#Read-data-and-convert-units" title="Permalink"></a></h2><p>First we need to read the data and convert it to physical units (unless you want to bother with comoving coordinates and <code>h0</code> in cosmological simulations).</p><p>Here <code>halo_pos</code> is the position of the halo you want to map and <code>rvir</code> is its virial radius.</p><pre><code class="language-julia hljs"># read the header
h = read_header(snap_base)
# define a unit conversion struct from `GadgetUnits.jl`
GU = GadgetPhysical(h)

# define the blocks you want to read
blocks = [&quot;POS&quot;, &quot;VEL&quot;, &quot;HSML&quot;, &quot;RHO&quot;, &quot;U&quot;, &quot;MASS&quot;, &quot;BFLD&quot;, &quot;MACH&quot;]

# read all particles in a cubic volume around the halo
data = read_particles_in_volume(snap_base, blocks, halo_pos, rvir)

# convert to physical code units for mapping
pos  = data[&quot;POS&quot;]  .* GU.x_physical
hsml = data[&quot;HSML&quot;] .* GU.x_physical
rho  = data[&quot;RHO&quot;]  .* GU.rho_physical
mass = data[&quot;MASS&quot;] .* GU.m_physical

# we want to map the entire cube we read
xy_size = 2rvir
z_size  = 2rvir

# define mapping parameters and convert to physical units
par = mappingParameters(center = halo_pos .* GU.x_physical,
                        x_size = xy_size * GU.x_physical,
                        y_size = xy_size * GU.x_physical,
                        z_size = z_size * GU.x_physical,
                        Npixels = 1024,
                        boxsize=h.boxsize)

# define the kernel you want to use for mapping
k = WendlandC4(Float64, 2)</code></pre><h2 id="D-surface-density"><a class="docs-heading-anchor" href="#D-surface-density">2D surface density</a><a id="D-surface-density-1"></a><a class="docs-heading-anchor-permalink" href="#D-surface-density" title="Permalink"></a></h2><p>To get the projected 2D surface density from your data you can use</p><pre><code class="language-julia hljs"># you need to make a copy of the positions if you plan to re-use them
# the mapping shifts them in place
pos_map = copy(pos)

# convert density to physical cgs units
rho_gcm3 = data[&quot;RHO&quot;] .* GU.rho_cgs

# to get the integrated values along the LOS you need physical weights and not reduce the image
weights = part_weight_physical(length(hsml), par, GU.x_cgs)

# actual mapping
map = sphMapping(pos_map, hsml, mass, rho,
                rho_gcm3, weights,
                param = par, kernel = k,
                reduce_image = false)

# filename of the output image
fo_image = map_path * &quot;rho.fits&quot;

# store the fits image
write_fits_image(fo_image, quantitiy_map, par, snap = snap, units = &quot;g/cm^2&quot;)</code></pre><p>The units in this case are of course <span>$g/cm^2$</span>.</p><h2 id="Magnetic-Field"><a class="docs-heading-anchor" href="#Magnetic-Field">Magnetic Field</a><a id="Magnetic-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Magnetic-Field" title="Permalink"></a></h2><p>To map the mean magnetic field along the LOS you need to use the density as weight (this is the default behaviour, so you can leave the arguemnt empty) and set <code>reduce_image=true</code></p><pre><code class="language-julia hljs"># you need to make a copy of the positions if you plan to re-use them
# the mapping shifts them in place
pos_map = copy(pos)

# compute absolute value of magnetic field in muG
B = @. 1.e6 * √(data[&quot;BFLD&quot;][1, :]^2 + data[&quot;BFLD&quot;][2, :]^2 + data[&quot;BFLD&quot;][3, :]^2)


# actual mapping
map = sphMapping(pos_map, hsml, mass, rho, B,
                param = par, kernel = k,
                reduce_image = true)

# filename of the output image
fo_image = map_path * &quot;B.fits&quot;

# store the fits image
write_fits_image(fo_image, quantitiy_map, par, snap = snap, units = &quot;muG&quot;)</code></pre><h2 id="X-Ray-emission"><a class="docs-heading-anchor" href="#X-Ray-emission">X-Ray emission</a><a id="X-Ray-emission-1"></a><a class="docs-heading-anchor-permalink" href="#X-Ray-emission" title="Permalink"></a></h2><p>To map the Xray surface brightness please use</p><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.x_ray_emissivity" href="#SPHtoGrid.x_ray_emissivity"><code>SPHtoGrid.x_ray_emissivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_ray_emissivity(T_keV::Vector{&lt;:Real}, 
                 rho_cgs::Vector{&lt;:Real},
                 metalicity::Union{Vector{Float64, Nothing}}=nothing; 
                 E0::Real=0.1, E1::Real=2.4, 
                 xH::Real=0.752,
                 cooling_function::Bool=false,
                 z::Real=0.0)</code></pre><p>X-Ray emissivity for particles with temperature <code>T_keV</code> in <span>$keV$</span>, and density <code>rho_cgs</code> in <span>$g/cm^3$</span>. If available you can also add the <code>metalicity</code> in the gas. <code>Emin</code> and <code>Emax</code> give the minimum and maximum energy of the oberservation. <code>xH</code> gives the hydrogen fraction used in the simulation.</p><p><strong>Returns</strong></p><p>X-Ray emissivity in units of [erg/s/cm^3].</p><p><strong>Arguments:</strong></p><ul><li><code>T_keV</code>: SPH particle temperature [keV]</li><li><code>m_cgs</code>: SPH particle mass in [g]</li><li><code>rho_cgs</code>: SPH particle density in [g/cm^3]</li><li><code>E0</code>: Minimum photon energy for Xray spectrum [keV]</li><li><code>E1</code>: Maximum photon energy for Xray spectrum [keV]</li><li><code>xH</code>: Hydrogen mass fraction in the simulation</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/x_ray.jl#L62-L90">source</a></section></article><p>Here is an example code</p><pre><code class="language-julia hljs"># you need to make a copy of the positions if you plan to re-use them
# the mapping shifts them in place
pos_map = copy(pos)

# get temperature in keV
T_keV = get_T_keV(data[&quot;U&quot;], data[&quot;MASS&quot;], GU.T_eV)

# convert density to physical cgs units
rho_gcm3 = data[&quot;RHO&quot;] .* GU.rho_cgs

# calculate X-ray emission per particle in the energy band Emin = 0.1 keV, Emax = 2.4 keV
Xray = x_ray_emissivity(T_keV, rho_cgs,
                        E0=0.1, E1=2.4)

# to get the integrated values along the LOS you need physical weights and not reduce the image
weights = part_weight_physical(length(hsml), par, GU.x_cgs)

# actual mapping
map = sphMapping(pos_map, hsml, mass, rho, Xray, weights,
                param = par, kernel = k,
                reduce_image = false)

# filename of the output image
fo_image = map_path * &quot;Xray.fits&quot;

# store the fits image
write_fits_image(fo_image, quantitiy_map, par, snap = snap, units = &quot;erg/s/cm^2&quot;)</code></pre><p>This returns a map in the units <span>$erg/s/cm^2$</span>.</p><h2 id="Sunyaev-Z&#39;eldovich-Effect"><a class="docs-heading-anchor" href="#Sunyaev-Z&#39;eldovich-Effect">Sunyaev-Z&#39;eldovich Effect</a><a id="Sunyaev-Z&#39;eldovich-Effect-1"></a><a class="docs-heading-anchor-permalink" href="#Sunyaev-Z&#39;eldovich-Effect" title="Permalink"></a></h2><p>You can compute compton-Y parameter, thermal and kinetic SZ effect with these functions:</p><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.comptonY" href="#SPHtoGrid.comptonY"><code>SPHtoGrid.comptonY</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">comptonY(n_cm3::Real, T_K::Real, z::Real)</code></pre><p>Computes the Compton-Y parameter from electron density <code>n_cm3</code> and temperature <code>T</code> in Kelvin at redshift <code>z</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>n_cm3</code>: SPH particle density in [1/cm^3]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>z</code>: Redshift.</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/sz_effect.jl#L61-L74">source</a></section><section><div><pre><code class="language-julia hljs">comptonY(n_cm3::Vector{&lt;:Real}, T_K::Vector{&lt;:Real}, z::Real)</code></pre><p>Computes the Compton-Y parameter from electron density <code>n_cm3</code> and temperature <code>T</code> in Kelvin at redshift <code>z</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>n_cm3</code>: SPH particle density in [1/cm^3]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>z</code>: Redshift</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/sz_effect.jl#L79-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.thermal_SZ" href="#SPHtoGrid.thermal_SZ"><code>SPHtoGrid.thermal_SZ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">thermal_SZ( n_cm3::Vector{&lt;:Real}, T_K::Vector{&lt;:Real},
            z::Real=0.0, ν::Real=1.44e9; 
            DI_over_I::Bool=false )</code></pre><p>Computes the thermal Sunyaev-Zel&#39;dovich effect for electron density <code>n_cm3</code> and temperature <code>T_K</code> in Kelvin at redshift <code>z</code> and observer frequency <code>ν</code>. <code>DI_over_I</code> outputs in units of <span>$dI/I$</span> if set to <code>true</code> and <code>dT/T</code> otherwise.</p><p><strong>Arguments:</strong></p><ul><li><code>n_cm3</code>: SPH particle density in [1/cm^3]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>z</code>: Redshift</li><li><code>ν</code>: Observing frequency</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/sz_effect.jl#L123-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.kinetic_SZ" href="#SPHtoGrid.kinetic_SZ"><code>SPHtoGrid.kinetic_SZ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kinetic_SZ(n_cm3::Real, vel_y_cgs::Real, 
           z::Real=0.0, ν::Real=1.e9;
           DI_over_I::Bool=false)</code></pre><p>Computes the kinetic Sunyaev-Zel&#39;dovich effect from electron density <code>n_cm3</code> and velocity in y-direction to the projection plane in cgs units <code>vel_y_cgs</code>. If <code>DI_over_I</code> is set to <code>true</code> you also need to provide an observation frequency <code>ν</code> and redshift <code>z</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>n_cm3</code>: SPH particle density in [1/cm^3]</li><li><code>vel_y_cgs</code>: SPH particle velocity in y-direction in [cm/s]</li><li><code>z</code>: Redshift</li><li><code>ν</code>: Observing frequency</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/sz_effect.jl#L26-L43">source</a></section></article><p>Example for the thermal SZ effect</p><pre><code class="language-julia hljs"># you need to make a copy of the positions if you plan to re-use them
# the mapping shifts them in place
pos_map = copy(pos)

# get temperature in K
T_K = data[&quot;U&quot;] .* GU.T_K

# convert code density to electron density
n_cm3 = data[&quot;RHO&quot;] .* GU.rho_ncm3

# calculate thermal SZ for redshift given in header
th_SZ = thermal_SZ(n_cm3, T_K, h.z)

# to get the integrated values along the LOS you need physical weights and not reduce the image
weights = part_weight_physical(length(hsml), par, GU.x_cgs)

# actual mapping
map = sphMapping(pos_map, hsml, mass, rho, th_SZ, weights,
                param = par, kernel = k,
                reduce_image = false)

# filename of the output image
fo_image = map_path * &quot;ThermalSZ.fits&quot;

# store the fits image
write_fits_image(fo_image, quantitiy_map, par, snap = snap, units = &quot;&quot;)</code></pre><h2 id="Gamma-Ray-emission"><a class="docs-heading-anchor" href="#Gamma-Ray-emission">Gamma Ray emission</a><a id="Gamma-Ray-emission-1"></a><a class="docs-heading-anchor-permalink" href="#Gamma-Ray-emission" title="Permalink"></a></h2><p>You can compute gamma-ray related maps as in <a href="https://ui.adsabs.harvard.edu/abs/2004A%26A...413...17P/abstract">Pfrommer &amp; Enßlin (2004)</a> with:</p><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.jγ_PE04" href="#SPHtoGrid.jγ_PE04"><code>SPHtoGrid.jγ_PE04</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jγ_PE04(rho_cgs::Real, T_K::Real, α_p::Real, Eγ::Real; 
        Xcr::Real=0.5, xH::Real=0.752)</code></pre><p>Gamma-ray emissivity at photon energy <code>Eγ</code> [GeV] for thermal gas with properties <code>rho_cgs</code> [g/cm^3] and <code>T_K</code> [K]. Sets up a CR proton spectrum with energy slope <code>α_p</code> as a fraction <code>Xcr</code> of the thermal energy density. Returns emissivity in units [GeV cm^-3 s^-1 ]. See Pfrommer&amp;Enßlin (2004), Eq. 19.</p><p><strong>Function Arguments:</strong></p><ul><li><code>rho_cgs</code>: SPH particle density in [g/cm^3]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>α_p</code>: Slope of proton energy spectrum <code>S ~ 2.0 - 2.5</code></li><li><code>Eγ</code>: Photon energy [GeV]</li><li><code>Xcr</code>: CR proton to thermal pressure ratio.</li><li><code>xH</code>: Hydrogen mass fraction in the simulation</li></ul><p><strong>Mapping settings</strong></p><p>For mean value along line-of-sight:</p><ul><li><code>weights</code>: <code>rho</code> (weight with density)</li><li><code>reduce_image</code>: <code>true</code></li></ul><p>For integral along line-of-sight, aka surface brightness:</p><ul><li><code>weights</code>: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li><code>reduce_image</code>: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/gamma.jl#L123-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.λγ_PE04" href="#SPHtoGrid.λγ_PE04"><code>SPHtoGrid.λγ_PE04</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λγ_PE04(rho_cgs::Real, T_K::Real, α_p::Real; 
        Xcr::Real=0.5,
        Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,
        xH::Real=0.752)</code></pre><p>Number of γ-ray photons produced per time and volume from a proton spectrum given as a fraction <code>Xcr</code> of the energy density defined by <code>rho_cgs</code> [g/cm^3] and <code>T_K</code> [K], with a powerlaw slope in energy <code>α_p</code>. Integrated between photon energies <code>Eγ_π0_min</code> and <code>Eγ_π0_max</code> [GeV]. Returns number of photons in energy band in units of [γ cm^-3 s^-1]. See Pfrommer&amp;Enßlin (2004), Eq. 25.</p><p><strong>Function Arguments:</strong></p><ul><li><code>rho_cgs</code>: SPH particle density in [g/cm^3]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>α_p</code>: Slope of proton energy spectrum <code>S ~ 2.0 - 2.5</code></li><li><code>Xcr</code>: CR proton to thermal pressure ratio.</li><li><code>Eγ_π0_min</code>: Minimum photon energy for γ-ray spectrum [GeV]</li><li><code>Eγ_π0_max</code>: Maximum photon energy for γ-ray spectrum [GeV]</li><li><code>xH</code>: Hydrogen mass fraction in the simulation</li></ul><p><strong>Mapping settings</strong></p><p>For mean value along line-of-sight:</p><ul><li><code>weights</code>: <code>rho</code> (weight with density)</li><li><code>reduce_image</code>: <code>true</code></li></ul><p>For integral along line-of-sight, aka surface brightness:</p><ul><li><code>weights</code>: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li><code>reduce_image</code>: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/gamma.jl#L157-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.gamma_luminosity_pions_PE04" href="#SPHtoGrid.gamma_luminosity_pions_PE04"><code>SPHtoGrid.gamma_luminosity_pions_PE04</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gamma_luminosity_pions_PE04(rho_cgs::Real, m_cgs::Real, T_K::Real, α_p::Real;
                            Xcr::Real=0.5,
                            Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,
                            xH::Real=0.752)</code></pre><p>γ-ray luminosity produced from a proton spectrum given as a fraction <code>Xcr</code> of the energy density defined by <code>rho_cgs</code> [g/cm^3] and <code>T_K</code> [K],  with a powerlaw slope in energy <code>α_p</code>. Integrated over SPH particle volume for particle of mass <code>m_cgs</code> [g]. Integrated between photon energies <code>Eγ_π0_min</code> and <code>Eγ_π0_max</code> [GeV]. Returns total luminosity integrated over energy band in units of [GeV s^-1]. See Pfrommer&amp;Enßlin (2004), Eq. 25.</p><p><strong>Arguments:</strong></p><ul><li><code>rho_cgs</code>: SPH particle density in [g/cm^3]</li><li><code>m_cgs</code>: SPH particle mass in [g]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>α_p</code>: Slope of proton energy spectrum <code>S ~ 2.0 - 2.5</code></li><li><code>Xcr</code>: CR proton to thermal pressure ratio.</li><li><code>Eγ_π0_min</code>: Minimum photon energy for γ-ray spectrum [GeV]</li><li><code>Eγ_π0_max</code>: Maximum photon energy for γ-ray spectrum [GeV]</li><li><code>xH</code>: Hydrogen mass fraction in the simulation</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_one"><code>part_weight_one</code></a></li><li>reduce image: <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/gamma.jl#L202-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.gamma_flux_pions_PE04" href="#SPHtoGrid.gamma_flux_pions_PE04"><code>SPHtoGrid.gamma_flux_pions_PE04</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gamma_flux_pions_PE04(rho_cgs::Real, m_cgs::Real, T_K::Real, α_p::Real, d::Real;
                      Xcr::Real=0.5,
                      Eγ_π0_min::Real=0.1, Eγ_π0_max::Real=200.0,
                      xH::Real=0.752)</code></pre><p>Flux of γ-ray photons produced from a proton spectrum given as a fraction <code>Xcr</code> of the energy density defined by <code>rho_cgs</code> [g/cm^3] and <code>T_K</code> [K],  with a powerlaw slope in energy <code>α_p</code>.  Integrated over SPH particle volume for particle of mass <code>m_cgs</code> [g]. Flux from a distance <code>d</code> [cm]. Integrated between photon energies <code>Eγ_π0_min</code> and <code>Eγ_π0_max</code> [GeV]. Returns total number of photons in energy band in untis of [γ cm^-2 s^-1]. See Pfrommer&amp;Enßlin (2004), Eq. 25.</p><p><strong>Arguments:</strong></p><ul><li><code>rho_cgs</code>: SPH particle density in [g/cm^3]</li><li><code>m_cgs</code>: SPH particle mass in [g]</li><li><code>T_K</code>: SPH particle temperature [K]</li><li><code>α_p</code>: Slope of proton energy spectrum <code>S ~ 2.0 - 2.5</code></li><li><code>d</code>: Distance to SPH particle or halo [cm].</li><li><code>Xcr</code>: CR proton to thermal pressure ratio.</li><li><code>Eγ_π0_min</code>: Minimum photon energy for γ-ray spectrum [GeV]</li><li><code>Eγ_π0_max</code>: Maximum photon energy for γ-ray spectrum [GeV]</li><li><code>xH</code>: Hydrogen mass fraction in the simulation</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_one"><code>part_weight_one</code></a></li><li>reduce image: <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/gamma.jl#L245-L274">source</a></section></article><p>Example for gamma-ray luminosity</p><pre><code class="language-julia hljs"># you need to make a copy of the positions if you plan to re-use them
# the mapping shifts them in place
pos_map = copy(pos)

# convert density to physical cgs units
rho_gcm3 = data[&quot;RHO&quot;] .* GU.rho_cgs

# convert mass to physical cgs units
m_cgs = data[&quot;MASS&quot;] .* GU.m_cgs

# get temperature in keV
T_keV = data[&quot;U&quot;] .* GU.T_K

# calculate Iγ-ray luminosity per particle in the energy band Emin = 0.1 GeV, Emax = 200 GeV
# for proton spectra with slope 2.235
Lγ = gamma_luminosity_pions_PE04.(T_keV, m_cgs, rho_cgs, 2.235)

# weights ones means you sum up the values along the LOS
weights = ones(length(Lγ))

# actual mapping
map = sphMapping(pos_map, hsml, mass, rho, Lγ, weights,
                param = par, kernel = k,
                reduce_image = true)

# filename of the output image
fo_image = map_path * &quot;L_gamma.fits&quot;

# store the fits image
write_fits_image(fo_image, quantitiy_map, par, snap = snap, units = &quot;GeV/s&quot;)</code></pre><h2 id="Synchrotron-Emission"><a class="docs-heading-anchor" href="#Synchrotron-Emission">Synchrotron Emission</a><a id="Synchrotron-Emission-1"></a><a class="docs-heading-anchor-permalink" href="#Synchrotron-Emission" title="Permalink"></a></h2><p>I implemented a number of different functions to compute synchrotron emissivity by shock accelerated electrons. Please use with caution as there are still some errors to be fixed!</p><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.analytic_synchrotron" href="#SPHtoGrid.analytic_synchrotron"><code>SPHtoGrid.analytic_synchrotron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">analytic_synchrotron(P_cgs::Array{&lt;:Real}, B_cgs::Array{&lt;:Real}, 
                     Mach::Array{&lt;:Real}, θ_B::Union{Nothing,Array{&lt;:Real}}=nothing;
                     dsa_model::Union{Integer,AbstractShockAccelerationEfficiency}=1, 
                     ν0::Real=1.4e9,
                     K_ep::Real=0.01, CR_Emin::Real=1.0,
                     spectrum::Union{Nothing,Function}=nothing,
                     integrate_pitch_angle::Bool=true,
                     polarisation::Bool=false,
                     show_progress::Bool=false)</code></pre><p>Computes the analytic synchrotron emission from a spectrum of electrons by explicitly integrating over the distribution function. The integral over the spectrum must be normalized to 1. The total energy density of the relativistic electrons is given by the CR to thermal pressure ratio obtained by employing a DSA model and computing Xcr as in <a href="https://ui.adsabs.harvard.edu/abs/2017MNRAS.465.4500P/abstract">Pfrommer et. al. (2017)</a>.</p><p>Returns synchrotron emissivity <code>j_nu</code> in units <code>[erg/s/Hz/cm^3]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>P_cgs::Array{&lt;:Real}</code>:   Thermal energy density in <code>erg/cm^3</code>.</li><li><code>B_cgs::Array{&lt;:Real}</code>:   Magnetic field in Gauss.</li><li><code>Mach::Array{&lt;:Real}</code>:    Mach number.</li><li><code>θ_B::Union{Nothing,Array{&lt;:Real}}=nothing</code>: Shock obliquity (optional).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ν0::Real=1.4e9</code>:           Observation frequency in <code>Hz</code>.</li><li><code>dsa_model</code>:      Diffusive Shock Acceleration model. Takes values <code>0...4</code>, or custom model. See next section.</li><li><code>K_ep::Real=0.01</code>:           Ratio of CR proton to electron energy acceleration.</li><li><code>CR_Emin::Real=1</code>:           Injection energy of CR electron population in <code>GeV</code>.</li><li><code>spectrum::Union{Nothing,Function}=nothing</code>: Spectrum function. Must be normalized so that the integral over it is 1.</li><li><code>integrate_pitch_angle::Bool=true</code>: Optional avoid pitch angle integration to reduce computational cost.</li><li><code>polarisation::Bool=false</code>: Set to <code>true</code> if you want to compute the polarized emission instead of the total intensity.</li><li><code>show_progress::Bool=false</code>: Enables a progress bar if set to true.</li></ul><p><strong>DSA Models</strong></p><p>Takes either your self-defined <code>AbstractShockAccelerationEfficiency</code> (see <a href="https://github.com/LudwigBoess/DiffusiveShockAccelerationModels.jl">DiffusiveShockAccelerationModels.jl</a> for details!) or a numerical value as input. Numerical values correspond to:</p><ul><li><code>0</code>: <a href="https://ui.adsabs.harvard.edu/abs/2007ApJ...669..729K/abstract">Kang et. al. (2007)</a></li><li><code>1</code>: <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...95K/abstract">Kang &amp; Ryu (2013)</a></li><li><code>2</code>: <a href="https://ui.adsabs.harvard.edu/abs/2019ApJ...883...60R/abstract">Ryu et. al. (2019)</a></li><li><code>3</code>: <a href="https://ui.adsabs.harvard.edu/abs/2014ApJ...783...91C/abstract">Caprioli &amp; Spitkovsky (2014)</a></li><li><code>4</code>: <a href="https://ui.adsabs.harvard.edu/abs/2006MNRAS.367..113P/abstract">Pfrommer et. al. (2006)</a></li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/synchrotron_LMB.jl#L178-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.analytic_synchrotron_GS" href="#SPHtoGrid.analytic_synchrotron_GS"><code>SPHtoGrid.analytic_synchrotron_GS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">analytic_synchrotron_GS( rho_cgs::Array{&lt;:Real}, B_cgs::Array{&lt;:Real},
                         T_K::Array{&lt;:Real}, Mach::Array{&lt;:Real};
                         xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.44e9,
                         integrate_pitch_angle::Bool=true )</code></pre><p>Computes the analytic synchrotron emission with the simplified approach described in Ginzburg &amp; Syrovatskii 1965, &quot;Cosmic Magnetobremsstrahlung&quot;. Uses the implementaion from <a href="https://ui.adsabs.harvard.edu/abs/2016MNRAS.462.2014D/abstract">Donnert et. al. (2016)</a>.</p><p>Returns synchrotron emissivity <code>j_nu</code> in units [erg/s/Hzcm^3].</p><p><strong>Arguments</strong></p><ul><li><code>rho_cgs::Array{&lt;:Real}</code>: Density in <span>$g/cm^3$</span>.</li><li><code>B_cgs::Array{&lt;:Real}</code>:   Magnetic field in Gauss.</li><li><code>T_K::Array{&lt;:Real}</code>:     Temperature in Kelvin.</li><li><code>Mach::Array{&lt;:Real}</code>:    Mach number.</li><li><code>θ_B::Union{Nothing,Array{&lt;:Real}}=nothing</code>: Shock obliquity (optional).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>xH::Float64 = 0.76</code>:        Hydrogen fraction of the simulation, if run without chemical model.</li><li><code>ν0::Real=1.44e9</code>:           Observation frequency in <span>$Hz$</span>.</li><li><code>dsa_model::Integer=1</code>:      Diffusive Shock Acceleration model. Takes values <code>0...4</code>, see next section.</li><li><code>K_ep::Real=0.01</code>:           Ratio of CR proton to electron energy acceleration.</li><li><code>show_progress::Bool=false</code>: Enables a progress bar if set to true</li></ul><p><strong>DSA Models</strong></p><p>Takes either your self-defined <code>AbstractShockAccelerationEfficiency</code> (see <a href="https://github.com/LudwigBoess/DiffusiveShockAccelerationModels.jl">DiffusiveShockAccelerationModels.jl</a> for details!) or a numerical value as input. Numerical values correspond to:</p><ul><li><code>0</code>: <a href="https://ui.adsabs.harvard.edu/abs/2007ApJ...669..729K/abstract">Kang et. al. (2007)</a></li><li><code>1</code>: <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...95K/abstract">Kang &amp; Ryu (2013)</a></li><li><code>2</code>: <a href="https://ui.adsabs.harvard.edu/abs/2019ApJ...883...60R/abstract">Ryu et. al. (2019)</a></li><li><code>3</code>: <a href="https://ui.adsabs.harvard.edu/abs/2014ApJ...783...91C/abstract">Caprioli &amp; Spitkovsky (2014)</a></li><li><code>4</code>: <a href="https://ui.adsabs.harvard.edu/abs/2006MNRAS.367..113P/abstract">Pfrommer et. al. (2006)</a></li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/synchrotron_GS.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.analytic_synchrotron_Longair" href="#SPHtoGrid.analytic_synchrotron_Longair"><code>SPHtoGrid.analytic_synchrotron_Longair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">analytic_synchrotron_emission( rho_cgs::Array{&lt;:Real}, B_cgs::Array{&lt;:Real},
                               T_K::Array{&lt;:Real}, Mach::Array{&lt;:Real};
                               xH::Real=0.76, dsa_model::Integer=1, ν0::Real=1.44e9,
                               integrate_pitch_angle::Bool=true )</code></pre><p>Computes the analytic synchrotron emission with the simplified approach described in Longair Eq. 8.128. Returns J_ν in units [erg/cm^3/Hz/s].</p><p><strong>Arguments</strong></p><ul><li><code>rho_cgs::Array{&lt;:Real}</code>: Density in <span>$g/cm^3$</span>.</li><li><code>B_cgs::Array{&lt;:Real}</code>:   Magnetic field in Gauss.</li><li><code>T_K::Array{&lt;:Real}</code>:     Temperature in Kelvin.</li><li><code>Mach::Array{&lt;:Real}</code>:    Mach number.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>xH::Float64 = 0.76</code>:               Hydrogen fraction of the simulation, if run without chemical model.</li><li><code>dsa_model::Integer=1</code>:             Diffuse-Shock-Acceleration model. Takes values <code>0...4</code>, see next section.</li><li><code>ν0::Real=1.44e9</code>:                  Observation frequency in <span>$Hz$</span>.</li><li><code>K_ep::Real=0.01</code>:                  Ratio of CR proton to electron energy density.</li><li><code>integrate_pitch_angle::Bool=true</code>: Integrates over the pitch angle as in Longair Eq. 8.87.</li><li><code>convert_to_mJy::Bool=false</code>:       Convert the result from <span>$[erg/cm^3/Hz/s]$</span> to <span>$mJy/cm$</span>.</li></ul><p><strong>DSA Models</strong></p><p>Takes either your self-defined <code>AbstractShockAccelerationEfficiency</code> (see <a href="https://github.com/LudwigBoess/DiffusiveShockAccelerationModels.jl">DiffusiveShockAccelerationModels.jl</a> for details!) or a numerical value as input. Numerical values correspond to:</p><ul><li><code>0</code>: <a href="https://ui.adsabs.harvard.edu/abs/2007ApJ...669..729K/abstract">Kang et. al. (2007)</a></li><li><code>1</code>: <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...95K/abstract">Kang &amp; Ryu (2013)</a></li><li><code>2</code>: <a href="https://ui.adsabs.harvard.edu/abs/2019ApJ...883...60R/abstract">Ryu et. al. (2019)</a></li><li><code>3</code>: <a href="https://ui.adsabs.harvard.edu/abs/2014ApJ...783...91C/abstract">Caprioli &amp; Spitkovsky (2014)</a></li><li><code>4</code>: <a href="https://ui.adsabs.harvard.edu/abs/2006MNRAS.367..113P/abstract">Pfrommer et. al. (2006)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/synchrotron_Longair.jl#L2-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.analytic_synchrotron_HB07" href="#SPHtoGrid.analytic_synchrotron_HB07"><code>SPHtoGrid.analytic_synchrotron_HB07</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">analytic_synchrotron_HB07( rho_cgs::Array{&lt;:Real}, m_cgs::Array{&lt;:Real}, hsml_cgs::Array{&lt;:Real},
                           B_cgs::Array{&lt;:Real}, T_keV::Array{&lt;:Real}, Mach::Array{&lt;:Real},
                           θ_B::Union{Nothing, Array{&lt;:Real}}=nothing;
                           xH::Real=0.752, ν0::Real=1.4e9, z::Real=0.0,
                           dsa_model::Union{Nothing,Integer,AbstractShockAccelerationEfficiency}=nothing,
                           ξe::Real=1.e-5,
                           show_progress::Bool=false )</code></pre><p>Computes the analytic synchrotron emission with the simplified approach described in <a href="https://ui.adsabs.harvard.edu/abs/2007MNRAS.375...77H/abstract">Hoeft&amp;Brüggen (2007)</a>, following approach by <a href="https://ui.adsabs.harvard.edu/abs/2017MNRAS.464.4448W/abstract">Wittor et. al. (2017)</a>.</p><p>Returns synchrotron emissivity <code>j_nu</code> in units [erg/s/Hz/cm^3].</p><p><strong>Arguments</strong></p><ul><li><code>rho_cgs::Array{&lt;:Real}</code>:  Density in <span>$g/cm^3$</span>.</li><li><code>m_cgs::Array{&lt;:Real}</code>:    Particle mass in <span>$g$</span>.</li><li><code>hsml_cgs::Array{&lt;:Real}</code>: <code>HSML</code> block in <span>$cm$</span>.</li><li><code>B_cgs::Array{&lt;:Real}</code>:    Magnetic field in <span>$G$</span>.</li><li><code>T_keV::Array{&lt;:Real}</code>:    Temperature in <span>$keV$</span>.</li><li><code>Mach::Array{&lt;:Real}</code>:     Sonic Mach number.</li><li><code>θ_B::Union{Nothing,Array{&lt;:Real}}=nothing</code>: Shock obliquity (optional).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>xH::Float64 = 0.76</code>:        Hydrogen fraction of the simulation, if run without chemical model.</li><li><code>ν0::Real=1.44e9</code>:           Observation frequency in <span>$Hz$</span>.</li><li><code>z::Real=0.0</code>:               Redshift of the simulation.</li><li><code>dsa_model=nothing</code>:         Diffusive Shock Acceleration model. If set to a value overwrites the default Hoeft&amp;Brüggen acceleration model. See next section.</li><li><code>ξe::Real=1.e-5</code>:            Ratio of CR proton to electron energy acceleration. Given as a fraction of thermal gas, essenitally <code>Xcr * Kep</code>.                               Default value from Nuza+2017. For <code>dsa_model != nothing</code> use something like <code>ξe = 1.e-4</code>.</li><li><code>show_progress::Bool=false</code>: Enables a progress bar if set to true.</li></ul><p><strong>DSA Models</strong></p><p>Takes either your self-defined <code>AbstractShockAccelerationEfficiency</code> (see <a href="https://github.com/LudwigBoess/DiffusiveShockAccelerationModels.jl">DiffusiveShockAccelerationModels.jl</a> for details!) or a numerical value as input. Numerical values correspond to:</p><ul><li><code>0</code>: <a href="https://ui.adsabs.harvard.edu/abs/2007ApJ...669..729K/abstract">Kang et. al. (2007)</a></li><li><code>1</code>: <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...95K/abstract">Kang &amp; Ryu (2013)</a></li><li><code>2</code>: <a href="https://ui.adsabs.harvard.edu/abs/2019ApJ...883...60R/abstract">Ryu et. al. (2019)</a></li><li><code>3</code>: <a href="https://ui.adsabs.harvard.edu/abs/2014ApJ...783...91C/abstract">Caprioli &amp; Spitkovsky (2014)</a></li><li><code>4</code>: <a href="https://ui.adsabs.harvard.edu/abs/2006MNRAS.367..113P/abstract">Pfrommer et. al. (2006)</a></li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/synchrotron_Hoeft.jl#L28-L73">source</a></section></article><h2 id="Stellar/DM-density"><a class="docs-heading-anchor" href="#Stellar/DM-density">Stellar/DM density</a><a id="Stellar/DM-density-1"></a><a class="docs-heading-anchor-permalink" href="#Stellar/DM-density" title="Permalink"></a></h2><p>If you want to map the mass density of a non-SPH particle, i.e. a particle distribution that does not have their density computed in the output snapshot you can do this with <code>mass_density</code>. This will perform an SPH loop to compute the mass density at particle position. Useful if you want to compute Stellar/DM density distributions.</p><p>Please note that this function uses a fixed number of neighbors (for simplicity) so the results will diverge from a proper SPH loop.</p><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.mass_density" href="#SPHtoGrid.mass_density"><code>SPHtoGrid.mass_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_density(pos::Matrix{&lt;:Real}, mass::Vector{&lt;:Real}; 
             kernel::AbstractSPHKernel=Cubic(Float64, 3),
             Nneighbors::Integer=32,
             boxsize::Vector{&lt;:Real}=zeros(3),
             verbose::Bool=false)</code></pre><p>Compute the density of an arbitrary particle distribution using the SPH method. Neighbor searches are performed using a (periodic) BallTree. The density is computed in input units, so additional unit conversion to cgs units is required, if input units are not cgs.</p><p><strong>Arguments:</strong></p><ul><li><code>pos</code>: particle position in physical code units.</li><li><code>mass</code>: particle mass in physical code units.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kernel::AbstractSPHKernel=Cubic(Float64, 3)</code>: SPH kernel to use for the density estimate. Works with any kernel from <a href="https://github.com/LudwigBoess/SPHKernels.jl">SPHKernels.jl</a>.</li><li><code>Nneighbors::Integer=32</code>: Number of neighboring particles to use for the density estimate.</li><li><code>boxsize::Vector{&lt;:Real}=zeros(3)</code>: Boxsize in each dimension. Used for periodic boundary conditions. If set to zero, non-periodic boundary conditions are assumed.</li><li><code>verbose::Bool=false</code>: If set to true gives progress reports and progress bar.</li></ul><p><strong>Returns</strong></p><ul><li><code>rho</code>:  mass density at particle position in input units.</li><li><code>hsml</code>: smoothing length of each particle in input units.</li></ul><p><strong>Mapping settings</strong></p><ul><li>weight function: <a href="../mapping/#SPHtoGrid.part_weight_physical"><code>part_weight_physical</code></a></li><li>reduce image: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/effects/mass_density.jl#L1-L29">source</a></section></article><h1 id="Image-Functions"><a class="docs-heading-anchor" href="#Image-Functions">Image Functions</a><a id="Image-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Functions" title="Permalink"></a></h1><h2 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.surface_brightness_to_luminosity" href="#SPHtoGrid.surface_brightness_to_luminosity"><code>SPHtoGrid.surface_brightness_to_luminosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surface_brightness_to_luminosity(map::Matrix{&lt;:Real}, pixelSideLength::Real; unit_factor::Real=1.0)</code></pre><p>Converts a map of surface brightness to luminosity per pixel. Uses <code>pixelSideLength</code> as the diameter of a pixel in <code>[kpc]</code>. If <code>unit_factor</code> is provided it is multiplied to every pixel to perform unit conversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/surface_brightness.jl#L1-L7">source</a></section><section><div><pre><code class="language-julia hljs">surface_brightness_to_luminosity(map::Matrix{&lt;:Real}, par::mappingParameters; unit_factor::Real=1.0)</code></pre><p>Converts a map of surface brightness to luminosity per pixel. If <code>unit_factor</code> is provided it is multiplied to every pixel to perform unit conversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/surface_brightness.jl#L19-L24">source</a></section></article><h2 id="Synchrotron-Specific"><a class="docs-heading-anchor" href="#Synchrotron-Specific">Synchrotron Specific</a><a id="Synchrotron-Specific-1"></a><a class="docs-heading-anchor-permalink" href="#Synchrotron-Specific" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.synchrotron_SB_to_luminosity" href="#SPHtoGrid.synchrotron_SB_to_luminosity"><code>SPHtoGrid.synchrotron_SB_to_luminosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">synchrotron_SB_to_luminosity(map, pixelSideLength::Real)</code></pre><p>Converts a map of synchrotron surface brightness <code>[erg/s/Hz/cm^2]</code> to synchrotron luminosity <code>[W/Hz]</code>. Uses <code>pixelSideLength</code> as the diameter of a pixel in <code>[kpc]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/synchrotron_luminosity.jl#L1-L6">source</a></section><section><div><pre><code class="language-julia hljs">synchrotron_SB_to_luminosity(map, par::mappingParameters)</code></pre><p>Converts a map of synchrotron surface brightness <code>[erg/s/Hz/cm^2]</code> to synchrotron luminosity <code>[W/Hz]</code>. Uses <code>par</code> as the <code>mappingParameters</code> of the original map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/synchrotron_luminosity.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.total_synch_luminosity_from_SB" href="#SPHtoGrid.total_synch_luminosity_from_SB"><code>SPHtoGrid.total_synch_luminosity_from_SB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">total_synch_luminosity_from_SB(map::Matrix{&lt;:Real}, pixelSideLength::Real)</code></pre><p>Computes the total synchrotron luminosity in <code>[W/Hz]</code> from a map of synchrotron surface brightness in <code>[erg/s/Hz/cm^2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/synchrotron_luminosity.jl#L21-L25">source</a></section><section><div><pre><code class="language-julia hljs">total_synch_luminosity_from_SB(map::Matrix{&lt;:Real}, par::mappingParameters)</code></pre><p>Computes the total synchrotron luminosity in <code>[W/Hz]</code> from a map of synchrotron surface brightness in <code>[erg/s/Hz/cm^2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/synchrotron_luminosity.jl#L31-L35">source</a></section><section><div><pre><code class="language-julia hljs">total_synch_luminosity_from_SB(filename::String)</code></pre><p>Computes the total synchrotron luminosity in <code>[W/Hz]</code> from a map of synchrotron surface brightness in <code>[erg/s/Hz/cm^2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/synchrotron_luminosity.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.beam_in_kpc" href="#SPHtoGrid.beam_in_kpc"><code>SPHtoGrid.beam_in_kpc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">beam_in_kpc(θ_beam::Vector{Union{Real, Unitful.AbstractQuantity}}, 
            c::Cosmology.AbstractCosmology, z::Real)</code></pre><p>Converts the beam from arcmin to kpc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/radio_beam.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.convert_Pnu_map_to_mJy_beam" href="#SPHtoGrid.convert_Pnu_map_to_mJy_beam"><code>SPHtoGrid.convert_Pnu_map_to_mJy_beam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_Pnu_map_to_mJy_beam(map::Matrix{&lt;:Real}, 
                            d_pixel::Real,
                            beam::Vector{Union{Real, Unitful.AbstractQuantity}}, 
                            c::Cosmology.AbstractCosmology, 
                            z::Real)</code></pre><p>Converts a map from units [W / Hz] to [mJy / beam].</p><p><strong>Parameters:</strong></p><ul><li><code>map</code>: original map in [W / Hz].</li><li><code>d_pixel</code>: size of a pixel in <span>$kpc$</span>.</li><li><code>beam</code>: dimensions of the beam in <span>$arcmin$</span>.</li><li><code>c</code>: Cosmology used for conversion.</li><li><code>z</code>: Redshift of the image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/radio_beam.jl#L24-L39">source</a></section><section><div><pre><code class="language-julia hljs">convert_Pnu_map_to_mJy_beam(map::Matrix{&lt;:Real}, 
                            d_pixel::Real,
                            beam::Union{Real, Unitful.AbstractQuantity}, 
                            c::Cosmology.AbstractCosmology, 
                            z::Real)</code></pre><p>Converts a map from units [W / Hz] to [mJy / beam] for a circular beam.</p><p><strong>Parameters:</strong></p><ul><li><code>map</code>: original map in [W / Hz].</li><li><code>d_pixel</code>: size of a pixel in <span>$kpc$</span>.</li><li><code>beam</code>: radius of the beam in <span>$arcmin$</span>.</li><li><code>c</code>: Cosmology used for conversion.</li><li><code>z</code>: Redshift of the image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/radio_beam.jl#L65-L80">source</a></section><section><div><pre><code class="language-julia hljs">convert_Pnu_map_to_mJy_beam(map::Matrix{&lt;:Real}, 
                            d_pixel::Real,
                            beam::Union{T, Vector{T}}, 
                            h::AbstractGadgetHeader) where T::Union{Real, Unitful.AbstractQuantity}</code></pre><p>Converts a map from units [W / Hz] to [mJy / beam] by using a Gadget header.</p><p><strong>Parameters:</strong></p><ul><li><code>map</code>: original map in [W / Hz].</li><li><code>d_pixel</code>: size of a pixel in <span>$kpc$</span>.</li><li><code>beam</code>: radius/dimensions of the beam in <span>$arcmin$</span>.</li><li><code>h</code>: Gadget header of simulation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/radio_beam.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.polarisation_fraction" href="#SPHtoGrid.polarisation_fraction"><code>SPHtoGrid.polarisation_fraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polarisation_fraction(Q_image, U_image, Iν_image, Iν_cutoff= 0.0)</code></pre><p>Compute the polarisation fraction image from Stokes Q and U images.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/stokes_parameters.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPHtoGrid.polarisation_angle" href="#SPHtoGrid.polarisation_angle"><code>SPHtoGrid.polarisation_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polarisation_angle(Q_image, U_image, Iν_image=nothing, Iν_cutoff= 0.0)</code></pre><p>Compute the polarisation fraction image from Stokes Q and U images.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LudwigBoess/SPHtoGrid.jl/blob/0fc16751520b4d1ba66c34944d4ed1a277959258/src/image_functions/stokes_parameters.jl#L18-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../healpix/">« HealPix maps</a><a class="docs-footer-nextpage" href="../rotating/">Rotating Images »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 6 May 2024 14:33">Monday 6 May 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
